# -*- coding: utf-8 -*-
"""Rescue_.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Nrd4yt8BUzwAgMv3v2hOXZGp0pi5-s4o

**Вычисление констант**
"""

def generate_round_constant(fn_name, field, idx, capacity = 2, security_level = 80):
    """
    Returns a field element based on the result of sha256.
    The input to sha256 is the concatenation of the name of the hash function
    and an index.
    For example, the first element for MiMC will be computed using the value
    of sha256('MiMC0').
    """
    from hashlib import sha256
    p = field
    m = idx
    num = ('%s%d' % (fn_name, idx)).encode('utf-8') # вариант из спецификации Rescue - Marvellous
    num = ("Rescue - XLIX (%i ,%i ,%i ,%i)" % (p, m, capacity, security_level)).encode('utf-8')  # (p , m ,capacity , security_level ) - вариант из спецификации Rescue-Prime

    val = int(sha256(num).hexdigest(), 16)
    return val % field

"""**Начальные параметры**

**Сложение и умножение полиномов Жегалкина**
"""

def Zheg_sum(poly1 : list, poly2 : list) -> list:
    for mono in poly2:
      try:
        poly1.remove(mono)
      except ValueError:
        poly1.append(mono) 
    poly1.sort()
    return poly1

    """
    poly_dict = dict.fromkeys(poly1, 1)
    for monom in poly2: 
        if ((poly_dict.pop(monom, 2)) == 2):
            poly_dict[monom] = 1
    poly3 = list(poly_dict.keys())  

    return poly3
    """
    

def Zheg_mul(poly1 : list, poly2 : list) -> list:

    poly3 = []
    for monom in poly1:
      tmp = poly3
      poly3 = Zheg_sum([monom | x for x in poly2], tmp)
      tmp.clear()
    poly3.sort()
    return poly3
    """  
    poly_dict = dict()
    for monom1 in poly1:
        for monom2 in poly2:
            monom = monom1 | monom2
            if ((poly_dict.pop(monom, 2)) == 2):
                poly_dict[monom] = 1
    poly3 = list(poly_dict.keys())
    return poly3
    """

def pow_of_p(p : int):
    n = 1
    while (2 ** n < p):
        n = n + 1
    return n
Zheg_mul([1, 2], [1, 2])

"""**Преобразования в полиномы Жегалкина по таблице истинности + по модулю p, * по модулю p на константу, возведение в степень по модулю p**"""

def transform_to_monoms(table: list, size_1, size_2 : int, shift_x : int):
    monoms = [[] for i in range(size_2)]
    for i in range(2 ** size_1): # пройти по всем элементам таблицы истинности
        for j in range(size_2 - 1, -1, -1): # простись по каждому биту
            shift = 1 << j    # 1, ..., n - расположение битов
            if (shift & table[i]):
                monoms[size_2 - j - 1].append(i << shift_x)
    return monoms

def mult_to_poly(p : int, size_p : int) : 
    test_func_table = []
    for x in range(2 ** size_p):
        for y in range(2 ** size_p):
            if ( y >= p):
                test_func_table.append(0)
            elif (x >= p):
                test_func_table.append(None)
            else:
                test_func_table.append((x * y) % p)
    
    trial_func_table = test_func_table.copy()
    # создай для сравнение полиномы и их длину
    jump = 1
    len_table = 2 ** (2 * size_p)

    # преобразование таблицы истинности в таблицу коэф. полинома Жегалкина
    for i in range(2 * size_p):
        j = jump # пропусти элементы 
        while(j < len_table):
            for k in range(0, jump):
                if (trial_func_table[j + k - jump] == None or trial_func_table[j + k] == None):
                    trial_func_table[j + k] = None
                else:
                    trial_func_table[j + k] ^= trial_func_table[j + k - jump]
            j += 2 * jump 
        jump *= 2
    len_table = len(trial_func_table)
    for i in range(len_table - 1, -1, -1):
        if (trial_func_table[i] == None):
            trial_func_table[i] = 0
        else:
            break
    monoms = transform_to_monoms(trial_func_table, 2 * size_p, size_p, 0)
    monom_size = [len(x) for x in monoms]
    """
    # маска - новые значения для таблицы = все 1
    mask = 0
    for i in range(size_p):
        mask = mask ^ (1 << i)

    for x in range(2 ** size_p):
        for y in range(2 ** size_p):
            if (x >= p or y >= p):
                idx = (x << size_p) ^ y
                test_func_table[idx] = mask
                trial_func_table.clear()
                trial_func_table = test_func_table.copy()
                jump = 1
                # преобразование таблицы истинности в таблицу коэф. полинома Жегалкина
                for i in range(2 * size_p):
                    j = jump # пропусти элементы 
                    while(j < len_table):
                        for k in range(0, jump):
                            trial_func_table[j + k] ^= trial_func_table[j + k - jump]
                        j += 2 * jump 
                    jump *= 2
                cur_monoms = transform_to_monoms(trial_func_table, 2 * size_p, size_p)
                cur_monom_size = [len(x) for x in monoms]
                new_table_value = 0

                for i in range(size_p):
                    if (cur_monom_size[i] < monom_size[i]):
                        new_table_value = new_table_value ^ (1 << (2 * size_p - i - 1))
                        monom_size[i] = cur_monom_size[i] # замени список мономов и их длину
                        monoms[i] = cur_monoms[i]
                test_func_table[idx] = new_table_value # замени на новые коэффициенты 


    # создай для сравнение полиномы и их длину
    jump = 1
    len_table = 2 ** (2 * size_p)
    # преобразование таблицы истинности в таблицу коэф. полинома Жегалкина
    for i in range(2 * size_p):
        j = jump # пропусти элементы 
        while(j < len_table):
            for k in range(0, jump):
                test_func_table[j + k] ^= test_func_table[j + k - jump]
            j += 2 * jump 
        jump *= 2
    monoms = transform_to_monoms(test_func_table, 2 * size_p, size_p)
    monom_size = [len(x) for x in monoms]      
    """
    return monoms

def sum_to_poly(p : int, size_p : int) : # возращает список мономов для каждого бита  Требует НАСТРОЙКИ !!!!
    test_func_table = []
    for x in range(2 ** size_p):
        for y in range(2 ** size_p):
            if ( y >= p):
                test_func_table.append(0)
            elif (x >= p):
                test_func_table.append(None)
            else:
                test_func_table.append((x + y) % p)
    
    trial_func_table = test_func_table.copy()
    # создай для сравнение полиномы и их длину
    jump = 1
    len_table = 2 ** (2 * size_p)

    # преобразование таблицы истинности в таблицу коэф. полинома Жегалкина
    for i in range(2 * size_p):
        j = jump # пропусти элементы 
        while(j < len_table):
            for k in range(0, jump):
                if (trial_func_table[j + k - jump] == None or trial_func_table[j + k] == None):
                    trial_func_table[j + k] = None
                else:
                    trial_func_table[j + k] ^= trial_func_table[j + k - jump]
            j += 2 * jump 
        jump *= 2
    len_table = len(trial_func_table)
    for i in range(len_table - 1, -1, -1):
        if (trial_func_table[i] == None):
            trial_func_table[i] = 0
        else:
            break
    monoms = transform_to_monoms(trial_func_table, 2 * size_p, size_p, 0)
    monom_size = [len(x) for x in monoms]
    """
    # маска - новые значения для таблицы = все 1
    mask = 0
    for i in range(size_p):
        mask = mask ^ (1 << i)

    for x in range(2 ** size_p):
        for y in range(2 ** size_p):
            if (x >= p or y >= p):
                idx = (x << size_p) ^ y
                test_func_table[idx] = mask
                trial_func_table.clear()
                trial_func_table = test_func_table.copy()
                jump = 1
                # преобразование таблицы истинности в таблицу коэф. полинома Жегалкина
                for i in range(2 * size_p):
                    j = jump # пропусти элементы 
                    while(j < len_table):
                        for k in range(0, jump):
                            trial_func_table[j + k] ^= trial_func_table[j + k - jump]
                        j += 2 * jump 
                    jump *= 2
                cur_monoms = transform_to_monoms(trial_func_table, 2 * size_p, size_p)
                cur_monom_size = [len(x) for x in monoms]
                new_table_value = 0

                for i in range(size_p):
                    if (cur_monom_size[i] < monom_size[i]):
                        new_table_value = new_table_value ^ (1 << (2 * size_p - i - 1))
                        monom_size[i] = cur_monom_size[i] # замени список мономов и их длину
                        monoms[i] = cur_monoms[i]
                test_func_table[idx] = new_table_value # замени на новые коэффициенты 


    # создай для сравнение полиномы и их длину
    jump = 1
    len_table = 2 ** (2 * size_p)
    # преобразование таблицы истинности в таблицу коэф. полинома Жегалкина
    for i in range(2 * size_p):
        j = jump # пропусти элементы 
        while(j < len_table):
            for k in range(0, jump):
                test_func_table[j + k] ^= test_func_table[j + k - jump]
            j += 2 * jump 
        jump *= 2
    monoms = transform_to_monoms(test_func_table, 2 * size_p, size_p)
    monom_size = [len(x) for x in monoms]      
    """
    return monoms

def mul_to_poly(p : int, a : int, size_p : int): # a - множитель 
    func_table = []
    for x in range(2 ** size_p):
        if (x < p):
            y = (x * a) % p
            func_table.append(y) 
        else:
            func_table.append(None)
    
    jump = 1
    len_table = 2 ** size_p

    # преобразование таблицы истинности в таблицу коэф. полинома Жегалкина
    for i in range(size_p):
        j = jump # пропусти элементы 
        while(j < len_table):
            for k in range(0, jump):
                if (func_table[j + k - jump] == None or func_table[j + k] == None):
                    func_table[j + k] = None
                else:
                    func_table[j + k] ^= func_table[j + k - jump]
            j += 2 * jump 
        jump *= 2
    
    len_table = len(func_table)
    for i in range(len_table - 1, -1, -1):
        if (func_table[i] == None):
            func_table[i] = 0
        else:
            break
    # Вывод коэффициентов
    """
    for el in func_table:
        pr_str = "0" * (size_p - len(bin(el)) + 2) + bin(el)[2:]
        print(pr_str)
    """
    return func_table

def const_sum_to_poly(p : int, a : int, size_p : int): # a - константа - слагаемое
    func_table = []
    for x in range(2 ** size_p):
        if (x < p):
            y = (x + a) % p
            func_table.append(y) 
        else:
            func_table.append(None)
    jump = 1
    len_table = 2 ** size_p

    # преобразование таблицы истинности в таблицу коэф. полинома Жегалкина
    for i in range(size_p):
        j = jump # пропусти элементы 
        while(j < len_table):
            for k in range(0, jump):
                if (func_table[j + k - jump] == None or func_table[j + k] == None):
                    func_table[j + k] = None
                else:
                    func_table[j + k] ^= func_table[j + k - jump]
            j += 2 * jump 
        jump *= 2
    
    len_table = len(func_table)
    for i in range(len_table - 1, -1, -1):
        if (func_table[i] == None):
            func_table[i] = 0
        else:
            break
    # Вывод коэффициентов
    """
    for el in func_table:
        pr_str = "0" * (size_p - len(bin(el)) + 2) + bin(el)[2:]
        print(pr_str)
    """
    return func_table 

def pow_to_poly(p : int, a : int, size_p : int): # p - простое число, модуль поля, a - степень, size_p - размер p в битах
    func_table = []
    for x in range(2 ** size_p):
        if (x < p):
            y = (x ** a) % p
            func_table.append(y) 
        else:
            func_table.append(None)
    jump = 1
    len_table = 2 ** size_p

    # преобразование таблицы истинности в таблицу коэф. полинома Жегалкина
    for i in range(size_p):
        j = jump # пропусти элементы 
        while(j < len_table):
            for k in range(0, jump):
                if (func_table[j + k - jump] == None or func_table[j + k] == None):
                    func_table[j + k] = None
                else:
                    func_table[j + k] ^= func_table[j + k - jump]
            j += 2 * jump 
        jump *= 2
    
    len_table = len(func_table)
    for i in range(len_table - 1, -1, -1):
        if (func_table[i] == None):
            func_table[i] = 0
        else:
            break
    # Вывод коэффициентов
    """
    for el in func_table:
        pr_str = "0" * (size_p - len(bin(el)) + 2) + bin(el)[2:]
        print(pr_str)
    """
    return func_table

p = 13
print(transform_to_monoms(const_sum_to_poly(p, 3, pow_of_p(p)), pow_of_p(p), pow_of_p(p), 0))
A = const_sum_to_poly(p, 3, pow_of_p(p))
for el in A:
    print(bin(el)[2:])

"""**Полиномы Жегалкина - умножение на матрицу вектора**"""

def substitution_of_poly_matrix(poly_sum : list, poly_ : list, size_p : int):
    poly_res = [[] for i in range(size_p)]
    for l in range(len(poly_sum)): # по всем полиномам каждого бита результата 
        poly_fin = {} 
        for monom in poly_sum[l]:  #  по всем мономам конкретного полинома 
            part_new_poly = [0] # константа 1
            for i in range(2 * size_p - 1, -1, -1): #какую переменную текуще заменяем 
                cur_x = 1 << i
                idx = 2 * size_p - 1 - i
                if (cur_x & monom != 0): # переменная есть в мономе
                    monom = monom ^ cur_x
                    part_new_poly = Zheg_mul(poly_[idx], part_new_poly) # умнож на соответствующий полином уже накопленный
            for new_monom in part_new_poly: 
                if (new_monom in poly_fin.keys()):
                    poly_fin[new_monom] = (poly_fin[new_monom] + 1) % 2
                else:
                    poly_fin[new_monom] = 1
        for monom in poly_fin.keys():
            if (poly_fin[monom] != 0):
                poly_res[l].append(monom)
        poly_res[l].sort()
    return poly_res

def Zheg_matrix(mds, p: int, m : int, size_p : int, th : int):
    Q_matrix = []
    new_value = size_p * m
    ind_new_val =[ ] # массив индексов новых переменных 
    matrix = []
    sum_ = sum_to_poly(p, size_p)
    for i in range(m):
        list1 = transform_to_monoms(mul_to_poly(p, mds[i][0], size_p), size_p, size_p, size_p * (m - 1)) # умножение 
    
        for j in range(1, m):
            list2 = transform_to_monoms(mul_to_poly(p, mds[i][j], size_p), size_p, size_p, size_p * (m - i - 1)) # умножение
            res = substitution_of_poly_matrix(sum_, list1 + list2, size_p)
            list1.clear()
            list1 = res
            list2.clear()
        matrix += res
    return matrix, Q_matrix, new_value

"""**Полиномы Жегалкина преобразования - параметр th и ввод вспомогательных переменных**"""

def Zheg_func_subst(p : int, size_p : int, m : int, func : list, arg : list, th : int, new_val_shift : int, length : int) :# -> list, list, int
    """
        new_val_shift - сдвиг 1, чтобы обозначить новую переменную 
    """
    result_subst = []
    Q = []
    val_shift = new_val_shift
    for i in range(len(func)): # по каждому полиному, выражающему один бит
        new_final_poly = []
        for monom in func[i]:
            new_poly = [0]
            idx = 1 << (length)
            const_0 = 0
            for j in range(length): 
                idx >>= 1
                # проверка длины - добавление новой переменной 
                if (len(new_poly) > th):
                        Q_file_rang = open("Q_file_rang.txt", 'a')
                        Q_file_len = open("Q_file_len.txt", 'a')
                        cnf_file = open("cnf_file.txt", 'a')
                        new_val = 1 << val_shift
                        val_shift += 1
                        new_q = Zheg_sum(new_poly, [0, new_val]) 
                        new_poly = [new_val]
                        rang = 0
                        for monom in new_q: 
                          rang += count_1(monom)
                        leng = len(new_q)
                        for T in [3, 4, 5]:
                          dnf, rng_cnf, new_value = RZP_cnf_one(new_q, T, alpha)
                          string = str(dnf) + " " + str(rng_cnf) + " " + str(new_value) + " "
                          cnf_file.write(string)
                        cnf_file.write("\n")
                        Q_file_rang.write(str(rang) + "\n")
                        Q_file_len.write(str(leng) + "\n")
                        Q_file_rang.close()
                        Q_file_len.close()
                        cnf_file.close()
                        #Q.append(new_q)
                if (monom & idx != 0):
                    const_0 = 1
                    new_poly = Zheg_mul(new_poly, arg[j]) 
            if (const_0 == 0):
                new_poly = []
            new_final_poly = Zheg_sum(new_final_poly, new_poly)
            new_poly.clear()
            if (len(new_final_poly) > th * th):
                Q_file_rang = open("Q_file_rang.txt", 'a')
                Q_file_len = open("Q_file_len.txt", 'a')
                cnf_file = open("cnf_file.txt", 'a')
                new_val = 1 << val_shift
                val_shift += 1
                new_q = Zheg_sum(new_final_poly, [0, new_val])
                new_final_poly = [new_val]
                rang = 0
                for monom in new_q: 
                  rang += count_1(monom)
                leng = len(new_q)
                for T in [3, 4, 5]:
                  dnf, rng_cnf, new_value = RZP_cnf_one(new_q, T, alpha)
                  string = str(dnf) + " " + str(rng_cnf) + " " + str(new_value) + " "
                  cnf_file.write(string)
                cnf_file.write("\n")
                Q_file_rang.write(str(rang) + "\n")
                Q_file_len.write(str(leng) + "\n")
                Q_file_rang.close()
                Q_file_len.close()
                cnf_file.close()
                #Q.append(new_q)
        result_subst.append(new_final_poly)
    
    return result_subst, Q, val_shift

"""**Преобразование S - M - C -- один раунд в полиномах жегалкина**"""

def Round(p: int, size_p : int, m : int, mds: list, alpha : int, round_number : int, shift : int, th: int):
    S = []
    for i in range(m - 1, -1, -1):
        S += transform_to_monoms(pow_to_poly(p, alpha, size_p), size_p, size_p, i * size_p)
    C = []
    for i in range(m):
        constant_ = generate_round_constant("Rescue", p, round_number * i) 
        C += transform_to_monoms(const_sum_to_poly(p, constant_, size_p), size_p, size_p, (m - i - 1) * size_p)
    M = Zheg_matrix(mds, p, m, size_p)
    Result, Q, new_shift = Zheg_func_subst(p, size_p, m, M, S, th, shift)
    Result, Q2, new_shift = Zheg_func_subst(p, size_p, m, C, Result, th, new_shift)
    return Result, Q + Q2, new_shift
#Round(7, 3, 4, MDS, alpha, 1, m * size_p, 14)

"""**k-Rounds**"""

MDSs = [
    [[ 8 , 12 , 7 ], 
[ 4 , 1 , 9 ], 
[4 , 1 , 9 ]] , 

[[ 10 , 12 , 13 ], 
[ 11 , 13 , 11 ], 
[11 , 13 , 11 ]] 
, 
[[ 8 , 5 , 7 ], 
[ 18 , 5 , 16 ], 
[18 , 5 , 16 ]] 
, 
[[ 10 , 6 , 8 ], 
[ 11 , 12 , 1 ], 
[11 , 12 , 1 ]] 
, 
[[ 8 , 15 , 7 ], 
[ 27 , 26 , 6 ], 
[27 , 26 , 6 ]] 
, 
[[ 27 , 23 , 13 ], 
[ 10 , 16 , 6 ], 
[10 , 16 , 6 ]] 
, 
[[ 8 , 23 , 7 ], 
[ 19 , 21 , 35 ], 
[19 , 21 , 35 ]] 
, 
[[ 11 , 29 , 2 ], 
[ 22 , 28 , 33 ], 
[22 , 28 , 33 ]] 
, 
[[ 27 , 4 , 13 ], 
[ 7 , 36 , 1 ], 
[7 , 36 , 1 ]] 
, 
[[ 31 , 33 , 31 ], 
[ 21 , 20 , 7 ], 
[21 , 20 , 7 ]] 
, 
[[ 8 , 39 , 7 ], 
[ 3 , 16 , 35 ], 
[3 , 16 , 35 ]] 
, 
[[ 8 , 45 , 7 ], 
[ 56 , 28 , 35 ], 
[56 , 28 , 35 ]] 
, 
[[ 8 , 47 , 7 ], 
[ 56 , 32 , 35 ], 
[56 , 32 , 35 ]] 
, 
[[ 8 , 53 , 7 ], 
[ 56 , 44 , 35 ], 
[56 , 44 , 35 ]] 
, 
[[ 59 , 27 , 57 ], 
[ 26 , 36 , 10 ], 
[26 , 36 , 10 ]] 
, 
[[ 52 , 64 , 31 ], 
[ 6 , 65 , 3 ], 
[6 , 65 , 3 ]] 
, 
[[ 27 , 40 , 13 ], 
[ 35 , 73 , 51 ], 
[35 , 73 , 51 ]] 
, 
[[ 8 , 69 , 7 ], 
[ 56 , 76 , 35 ], 
[56 , 76 , 35 ]] 
, 
[[ 27 , 50 , 13 ], 
[ 84 , 54 , 41 ], 
[84 , 54 , 41 ]] 
, 
[[ 28 , 39 , 31 ], 
[ 92 , 73 , 30 ], 
[92 , 73 , 30 ]] 
, 
[[ 8 , 87 , 7 ], 
[ 56 , 11 , 35 ], 
[56 , 11 , 35 ]] 
, 
[[ 22 , 51 , 31 ], 
[ 64 , 58 , 85 ], 
[64 , 58 , 85 ]] 
, 
[[ 8 , 93 , 7 ], 
[ 56 , 17 , 35 ], 
[56 , 17 , 35 ]] 
, 
[[ 107 , 69 , 43 ], 
[ 23 , 22 , 65 ], 
[23 , 22 , 65 ]] 
, 
[[ 27 , 74 , 13 ], 
[ 12 , 85 , 17 ], 
[12 , 85 , 17 ]] 
, 
[[ 27 , 88 , 13 ], 
[ 97 , 28 , 3 ], 
[97 , 28 , 3 ]] 
, 
[[ 8 , 117 , 7 ], 
[ 56 , 41 , 35 ], 
[56 , 41 , 35 ]] 
, 
[[ 27 , 98 , 13 ], 
[ 77 , 68 , 130 ], 
[77 , 68 , 130 ]] 
, 
[[ 8 , 125 , 7 ], 
[ 56 , 49 , 35 ], 
[56 , 49 , 35 ]] 
, 
[[ 8 , 135 , 7 ], 
[ 56 , 59 , 35 ], 
[56 , 59 , 35 ]] 
, 
[[ 65 , 44 , 43 ], 
[ 77 , 145 , 81 ], 
[77 , 145 , 81 ]] 
, 
[[ 125 , 2 , 31 ], 
[ 107 , 30 , 21 ], 
[107 , 30 , 21 ]] 
, 
[[ 8 , 149 , 7 ], 
[ 56 , 73 , 35 ], 
[56 , 73 , 35 ]] 
, 
[[ 125 , 12 , 31 ], 
[ 34 , 163 , 138 ], 
[34 , 163 , 138 ]] 
, 
[[ 8 , 159 , 7 ], 
[ 56 , 83 , 35 ], 
[56 , 83 , 35 ]] 
, 
[[ 8 , 165 , 7 ], 
[ 56 , 89 , 35 ], 
[56 , 89 , 35 ]] 
, 
[[ 8 , 167 , 7 ], 
[ 56 , 91 , 35 ], 
[56 , 91 , 35 ]] 
, 
[[ 174 , 19 , 190 ], 
[ 17 , 155 , 20 ], 
[17 , 155 , 20 ]] 
, 
[[ 125 , 38 , 31 ], 
[ 15 , 145 , 34 ], 
[15 , 145 , 34 ]] 
, 
[[ 8 , 183 , 7 ], 
[ 56 , 107 , 35 ], 
[56 , 107 , 35 ]] 
, 
[[ 27 , 160 , 13 ], 
[ 152 , 117 , 130 ], 
[152 , 117 , 130 ]] 
, 
[[ 8 , 197 , 7 ], 
[ 56 , 121 , 35 ], 
[56 , 121 , 35 ]] 
, 
[[ 27 , 184 , 13 ], 
[ 128 , 189 , 130 ], 
[128 , 189 , 130 ]] 
, 
[[ 8 , 213 , 7 ], 
[ 56 , 137 , 35 ], 
[56 , 137 , 35 ]] 
, 
[[ 216 , 200 , 43 ], 
[ 128 , 114 , 217 ], 
[128 , 114 , 217 ]] 
, 
[[ 27 , 194 , 13 ], 
[ 118 , 219 , 130 ], 
[118 , 219 , 130 ]] 
, 
[[ 104 , 79 , 57 ], 
[ 192 , 66 , 221 ], 
[192 , 66 , 221 ]] 
, 
[[ 102 , 83 , 57 ], 
[ 30 , 13 , 199 ], 
[30 , 13 , 199 ]] 
, 
[[ 216 , 244 , 43 ], 
[ 1 , 166 , 85 ], 
[1 , 166 , 85 ]] 
, 
[[ 27 , 218 , 13 ], 
[ 94 , 34 , 130 ], 
[94 , 34 , 130 ]] 
, 
[[ 125 , 108 , 31 ], 
[ 193 , 54 , 17 ], 
[193 , 54 , 17 ]] 
, 
[[ 8 , 255 , 7 ], 
[ 56 , 179 , 35 ], 
[56 , 179 , 35 ]] 
, 
[[ 216 , 13 , 43 ], 
[ 74 , 233 , 236 ], 
[74 , 233 , 236 ]] 
, 
[[ 125 , 122 , 31 ], 
[ 274 , 29 , 252 ], 
[274 , 29 , 252 ]] 
, 
[[ 27 , 242 , 13 ], 
[ 70 , 82 , 130 ], 
[70 , 82 , 130 ]] 
, 
[[ 27 , 244 , 13 ], 
[ 68 , 86 , 130 ], 
[68 , 86 , 130 ]] 
, 
[[ 8 , 279 , 7 ], 
[ 56 , 203 , 35 ], 
[56 , 203 , 35 ]] 
, 
[[ 125 , 152 , 31 ], 
[ 191 , 232 , 192 ], 
[191 , 232 , 192 ]] 
, 
[[ 248 , 68 , 307 ], 
[ 252 , 287 , 84 ], 
[252 , 287 , 84 ]] 
, 
[[ 61 , 142 , 111 ], 
[ 198 , 173 , 256 ], 
[198 , 173 , 256 ]] 
, 
[[ 8 , 303 , 7 ], 
[ 56 , 227 , 35 ], 
[56 , 227 , 35 ]] 
, 
[[ 27 , 292 , 13 ], 
[ 20 , 182 , 130 ], 
[20 , 182 , 130 ]] 
, 
[[ 326 , 238 , 111 ], 
[ 127 , 121 , 90 ], 
[127 , 121 , 90 ]] 
, 
[[ 8 , 333 , 7 ], 
[ 56 , 257 , 35 ], 
[56 , 257 , 35 ]] 
, 
[[ 8 , 335 , 7 ], 
[ 56 , 259 , 35 ], 
[56 , 259 , 35 ]] 
, 
[[ 27 , 314 , 13 ], 
[ 351 , 226 , 130 ], 
[351 , 226 , 130 ]] 
, 
[[ 343 , 319 , 57 ], 
[ 165 , 217 , 337 ], 
[165 , 217 , 337 ]] 
, 
[[ 216 , 109 , 43 ], 
[ 113 , 132 , 123 ], 
[113 , 132 , 123 ]] 
, 
[[ 8 , 359 , 7 ], 
[ 56 , 283 , 35 ], 
[56 , 283 , 35 ]] 
, 
[[ 8 , 365 , 7 ], 
[ 56 , 289 , 35 ], 
[56 , 289 , 35 ]] 
, 
[[ 125 , 228 , 31 ], 
[ 45 , 299 , 40 ], 
[45 , 299 , 40 ]] 
, 
[[ 8 , 375 , 7 ], 
[ 56 , 299 , 35 ], 
[56 , 299 , 35 ]] 
, 
[[ 125 , 242 , 31 ], 
[ 302 , 84 , 12 ], 
[302 , 84 , 12 ]] 
, 
[[ 27 , 362 , 13 ], 
[ 351 , 322 , 130 ], 
[351 , 322 , 130 ]] 
, 
[[ 263 , 93 , 54 ], 
[ 296 , 377 , 146 ], 
[296 , 377 , 146 ]] 
, 
[[ 8 , 405 , 7 ], 
[ 56 , 329 , 35 ], 
[56 , 329 , 35 ]] 
, 
[[ 8 , 407 , 7 ], 
[ 56 , 331 , 35 ], 
[56 , 331 , 35 ]] 
, 
[[ 343 , 32 , 57 ], 
[ 156 , 12 , 264 ], 
[156 , 12 , 264 ]] 
, 
[[ 125 , 278 , 31 ], 
[ 411 , 83 , 373 ], 
[411 , 83 , 373 ]] 
, 
[[ 302 , 336 , 241 ], 
[ 347 , 63 , 30 ], 
[347 , 63 , 30 ]] 
, 
[[ 8 , 429 , 7 ], 
[ 56 , 353 , 35 ], 
[56 , 353 , 35 ]] 
, 
[[ 27 , 410 , 13 ], 
[ 351 , 418 , 130 ], 
[351 , 418 , 130 ]] 
, 
[[ 369 , 363 , 183 ], 
[ 348 , 76 , 34 ], 
[348 , 76 , 34 ]] 
, 
[[ 8 , 447 , 7 ], 
[ 56 , 371 , 35 ], 
[56 , 371 , 35 ]] 
, 
[[ 27 , 424 , 13 ], 
[ 351 , 446 , 130 ], 
[351 , 446 , 130 ]] 
, 
[[ 8 , 453 , 7 ], 
[ 56 , 377 , 35 ], 
[56 , 377 , 35 ]] 
, 
[[ 281 , 16 , 183 ], 
[ 170 , 335 , 454 ], 
[170 , 335 , 454 ]] 
, 
[[ 27 , 448 , 13 ], 
[ 351 , 7 , 130 ], 
[351 , 7 , 130 ]] 
, 
[[ 8 , 477 , 7 ], 
[ 56 , 401 , 35 ], 
[56 , 401 , 35 ]] 
, 
[[ 343 , 100 , 57 ], 
[ 90 , 55 , 355 ], 
[90 , 55 , 355 ]] 
, 
[[ 125 , 348 , 31 ], 
[ 354 , 350 , 303 ], 
[354 , 350 , 303 ]] 
, 
[[ 8 , 495 , 7 ], 
[ 56 , 419 , 35 ], 
[56 , 419 , 35 ]] 
, 
[[ 27 , 482 , 13 ], 
[ 351 , 41 , 130 ], 
[351 , 41 , 130 ]] 
, 
[[ 8 , 509 , 7 ], 
[ 56 , 433 , 35 ], 
[56 , 433 , 35 ]] 
, 
[[ 8 , 527 , 7 ], 
[ 56 , 451 , 35 ], 
[56 , 451 , 35 ]] 
, 
[[ 8 , 533 , 7 ], 
[ 56 , 457 , 35 ], 
[56 , 457 , 35 ]] 
, 
[[ 8 , 543 , 7 ], 
[ 56 , 467 , 35 ], 
[56 , 467 , 35 ]] 
, 
[[ 8 , 549 , 7 ], 
[ 56 , 473 , 35 ], 
[56 , 473 , 35 ]] 
, 
[[ 27 , 530 , 13 ], 
[ 351 , 89 , 130 ], 
[351 , 89 , 130 ]] 
, 
[[ 27 , 532 , 13 ], 
[ 351 , 91 , 130 ], 
[351 , 91 , 130 ]] 
, 
[[ 125 , 422 , 31 ], 
[ 413 , 513 , 229 ], 
[413 , 513 , 229 ]] 
, 
[[ 8 , 573 , 7 ], 
[ 56 , 497 , 35 ], 
[56 , 497 , 35 ]] 
, 
[[ 27 , 554 , 13 ], 
[ 351 , 113 , 130 ], 
[351 , 113 , 130 ]] 
, 
[[ 343 , 200 , 57 ], 
[ 383 , 362 , 454 ], 
[383 , 362 , 454 ]] 
, 
[[ 343 , 202 , 57 ], 
[ 319 , 438 , 446 ], 
[319 , 438 , 446 ]] 
, 
[[ 27 , 568 , 13 ], 
[ 351 , 127 , 130 ], 
[351 , 127 , 130 ]] 
, 
[[ 8 , 599 , 7 ], 
[ 56 , 523 , 35 ], 
[56 , 523 , 35 ]] 
, 
[[ 27 , 578 , 13 ], 
[ 351 , 137 , 130 ], 
[351 , 137 , 130 ]] 
, 
[[ 8 , 605 , 7 ], 
[ 56 , 529 , 35 ], 
[56 , 529 , 35 ]] 
, 
[[ 27 , 592 , 13 ], 
[ 351 , 151 , 130 ], 
[351 , 151 , 130 ]] 
, 
[[ 27 , 602 , 13 ], 
[ 351 , 161 , 130 ], 
[351 , 161 , 130 ]] 
, 
[[ 45 , 466 , 133 ], 
[ 198 , 295 , 151 ], 
[198 , 295 , 151 ]] 
, 
[[ 125 , 492 , 31 ], 
[ 640 , 496 , 159 ], 
[640 , 496 , 159 ]] 
, 
[[ 8 , 639 , 7 ], 
[ 56 , 563 , 35 ], 
[56 , 563 , 35 ]] 
, 
[[ 8 , 645 , 7 ], 
[ 56 , 569 , 35 ], 
[56 , 569 , 35 ]] 
, 
[[ 8 , 647 , 7 ], 
[ 56 , 571 , 35 ], 
[56 , 571 , 35 ]] 
, 
[[ 125 , 518 , 31 ], 
[ 510 , 31 , 133 ], 
[510 , 31 , 133 ]] 
, 
[[ 8 , 663 , 7 ], 
[ 56 , 587 , 35 ], 
[56 , 587 , 35 ]] 
, 
[[ 125 , 528 , 31 ], 
[ 460 , 101 , 123 ], 
[460 , 101 , 123 ]] 
, 
[[ 27 , 652 , 13 ], 
[ 351 , 211 , 130 ], 
[351 , 211 , 130 ]] 
, 
[[ 8 , 687 , 7 ], 
[ 56 , 611 , 35 ], 
[56 , 611 , 35 ]] 
, 
[[ 8 , 695 , 7 ], 
[ 56 , 619 , 35 ], 
[56 , 619 , 35 ]] 
, 
[[ 612 , 694 , 133 ], 
[ 149 , 163 , 408 ], 
[149 , 163 , 408 ]] 
, 
[[ 125 , 572 , 31 ], 
[ 240 , 409 , 79 ], 
[240 , 409 , 79 ]] 
, 
[[ 216 , 475 , 43 ], 
[ 492 , 117 , 125 ], 
[492 , 117 , 125 ]] 
, 
[[ 27 , 700 , 13 ], 
[ 351 , 259 , 130 ], 
[351 , 259 , 130 ]] 
, 
[[ 125 , 588 , 31 ], 
[ 160 , 521 , 63 ], 
[160 , 521 , 63 ]] 
, 
[[ 27 , 712 , 13 ], 
[ 351 , 271 , 130 ], 
[351 , 271 , 130 ]] 
, 
[[ 8 , 743 , 7 ], 
[ 56 , 667 , 35 ], 
[56 , 667 , 35 ]] 
, 
[[ 216 , 503 , 43 ], 
[ 156 , 537 , 69 ], 
[156 , 537 , 69 ]] 
, 
[[ 562 , 75 , 133 ], 
[ 153 , 540 , 77 ], 
[153 , 540 , 77 ]] 
, 
[[ 8 , 759 , 7 ], 
[ 56 , 683 , 35 ], 
[56 , 683 , 35 ]] 
, 
[[ 8 , 773 , 7 ], 
[ 56 , 697 , 35 ], 
[56 , 697 , 35 ]] 
, 
[[ 8 , 783 , 7 ], 
[ 56 , 707 , 35 ], 
[56 , 707 , 35 ]] 
, 
[[ 27 , 770 , 13 ], 
[ 351 , 329 , 130 ], 
[351 , 329 , 130 ]] 
, 
[[ 27 , 772 , 13 ], 
[ 351 , 331 , 130 ], 
[351 , 331 , 130 ]] 
, 
[[ 8 , 807 , 7 ], 
[ 56 , 731 , 35 ], 
[56 , 731 , 35 ]] 
, 
[[ 27 , 784 , 13 ], 
[ 351 , 343 , 130 ], 
[351 , 343 , 130 ]] 
, 
[[ 8 , 813 , 7 ], 
[ 56 , 737 , 35 ], 
[56 , 737 , 35 ]] 
, 
[[ 8 , 815 , 7 ], 
[ 56 , 739 , 35 ], 
[56 , 739 , 35 ]] 
, 
[[ 492 , 215 , 133 ], 
[ 833 , 561 , 285 ], 
[833 , 561 , 285 ]] 
, 
[[ 8 , 839 , 7 ], 
[ 56 , 763 , 35 ], 
[56 , 763 , 35 ]] 
, 
[[ 27 , 818 , 13 ], 
[ 351 , 377 , 130 ], 
[351 , 377 , 130 ]] 
, 
[[ 8 , 845 , 7 ], 
[ 56 , 769 , 35 ], 
[56 , 769 , 35 ]] 
, 
[[ 125 , 708 , 31 ], 
[ 423 , 498 , 806 ], 
[423 , 498 , 806 ]] 
, 
[[ 8 , 863 , 7 ], 
[ 56 , 787 , 35 ], 
[56 , 787 , 35 ]] 
, 
[[ 27 , 842 , 13 ], 
[ 351 , 401 , 130 ], 
[351 , 401 , 130 ]] 
, 
[[ 8 , 869 , 7 ], 
[ 56 , 793 , 35 ], 
[56 , 793 , 35 ]] 
, 
[[ 125 , 732 , 31 ], 
[ 327 , 642 , 806 ], 
[327 , 642 , 806 ]] 
, 
[[ 8 , 893 , 7 ], 
[ 56 , 817 , 35 ], 
[56 , 817 , 35 ]] 
, 
[[ 358 , 247 , 307 ], 
[ 586 , 574 , 663 ], 
[586 , 574 , 663 ]] 
, 
[[ 343 , 520 , 57 ], 
[ 252 , 575 , 93 ], 
[252 , 575 , 93 ]] 
, 
[[ 27 , 890 , 13 ], 
[ 351 , 449 , 130 ], 
[351 , 449 , 130 ]] 
, 
[[ 125 , 782 , 31 ], 
[ 127 , 5 , 806 ], 
[127 , 5 , 806 ]] 
, 
[[ 8 , 927 , 7 ], 
[ 56 , 851 , 35 ], 
[56 , 851 , 35 ]] 
, 
[[ 8 , 933 , 7 ], 
[ 56 , 857 , 35 ], 
[56 , 857 , 35 ]] 
, 
[[ 27 , 914 , 13 ], 
[ 351 , 473 , 130 ], 
[351 , 473 , 130 ]] 
, 
[[ 125 , 812 , 31 ], 
[ 7 , 155 , 806 ], 
[7 , 155 , 806 ]] 
, 
[[ 216 , 713 , 43 ], 
[ 549 , 774 , 620 ], 
[549 , 774 , 620 ]] 
, 
[[ 27 , 938 , 13 ], 
[ 351 , 497 , 130 ], 
[351 , 497 , 130 ]] 
, 
[[ 125 , 828 , 31 ], 
[ 926 , 235 , 806 ], 
[926 , 235 , 806 ]] 
, 
[[ 216 , 733 , 43 ], 
[ 369 , 23 , 600 ], 
[369 , 23 , 600 ]] 
, 
[[ 343 , 598 , 57 ], 
[ 608 , 531 , 856 ], 
[608 , 531 , 856 ]] 
, 
[[ 322 , 555 , 133 ], 
[ 448 , 480 , 82 ], 
[448 , 480 , 82 ]] 
, 
[[ 27 , 974 , 13 ], 
[ 351 , 533 , 130 ], 
[351 , 533 , 130 ]] 
, 
[[ 8 , 1005 , 7 ], 
[ 56 , 929 , 35 ], 
[56 , 929 , 35 ]] 
, 
[[ 1000 , 932 , 111 ], 
[ 732 , 310 , 1001 ], 
[732 , 310 , 1001 ]] 
 
]

def files(idx: int, Result, new_shift, r, p, old_data): 
  count_polys = old_data[2]
  sum_rang = old_data[0]
  sum_len = old_data[1]

  Q_file_rang = open("Q_file_rang.txt", 'r')
  Q_file_len = open("Q_file_len.txt", 'r')
  cnf_file = open("cnf_file.txt", 'r')

  poly_file = open("poly_file.txt", 'a')
  file_T3 = open("T3.txt", 'a')
  file_T4 = open("T4.txt", 'a')
  file_T5 = open("T5.txt", 'a')
  data_T3 = old_data[3:6]
  data_T4 = old_data[6:9]
  data_T5 = old_data[9:]
  print('ooold data ', old_data)
  line = Q_file_rang.readline()
  while (line):
        data = []
        data += [int(x) for x in line.split()]
        count_polys += 1
        sum_rang += data[0]
        line = Q_file_rang.readline()
  line = Q_file_len.readline()
  while (line):
        data = []
        data += [int(x) for x in line.split()]
        sum_len += data[0]
        line = Q_file_len.readline()
  line = cnf_file.readline()
  if (idx == 1): 
    for i in range(r):
      for j in range(pow_of_p(p)):
        rang = 0
        for monom in Result[i + j]: 
          sum_rang += count_1(monom)
        sum_len += len(Result[i + j])
        for T in [3, 4, 5]:
            dnf, rng_cnf, new_value = RZP_cnf_one(Result[i + j], T, alpha)
            if (T == 3):
              data_T3[0] += dnf
              data_T3[1] += rng_cnf
              data_T3[2] += new_value
            if (T == 4):
              data_T4[0] += dnf
              data_T4[1] += rng_cnf
              data_T4[2] += new_value
            if (T == 5):
              data_T5[0] += dnf
              data_T5[1] += rng_cnf
              data_T5[2] += new_value
        count_polys += 1      
  string = str(math.ceil(sum_rang / count_polys)) + " " + str(math.ceil(sum_len / count_polys)) + " " + str(new_shift) + '\n'
  poly_file.write(string)
  while (line):
        data = []
        data += [int(x) for x in line.split()]
        data_T3[0] += data[0]
        data_T3[1] += data[1]
        data_T3[2] += data[2]

        data_T4[0] += data[3]
        data_T4[1] += data[4]
        data_T4[2] += data[5]

        data_T5[0] += data[6]
        data_T5[1] += data[7]
        data_T5[2] += data[8]
        line = cnf_file.readline()
  
  string1 = str(data_T3[0]) + " " + str(data_T3[1]) + " " + str(data_T3[2]) + "\n"
  string2 = str(data_T4[0]) + " " + str(data_T4[1]) + " " + str(data_T4[2]) + "\n"
  string3 = str(data_T5[0]) + " " + str(data_T5[1]) + " " + str(data_T5[2]) + "\n"
  file_T3.write(string1)
  file_T4.write(string2)
  file_T5.write(string3)

  file_T3.close()
  file_T4.close()
  file_T5.close()
  poly_file.close()
  Q_file_rang.close()
  Q_file_len.close()
  cnf_file.close()
  new_data = [sum_rang, sum_len, count_polys] + data_T3 + data_T4 + data_T5
  print('new data', new_data)
  return new_data

from numpy.lib.polynomial import polysub
import os
def k_Rounds(p: int, size_p : int, m : int, r: int, mds: list, alpha : int, alpha1 : int, k : int, th: int):
    

    new_shift = m * size_p
    Q_final = []
    S0 = []
    for i in range(m - 1, -1, -1):
        S0 += transform_to_monoms(pow_to_poly(p, alpha, size_p), size_p, size_p, i * size_p)
        if (i == (m - r)):
            Result = S0.copy()
        if (i < (m - r)):
            Result += [[] for j in range(pow_of_p(p))]
    S1 = []
    for i in range(m - 1, -1, -1):
        S1 += transform_to_monoms(pow_to_poly(p, alpha1, size_p), size_p, size_p, i * size_p)
    for i in range(len(Result)):
        if (len(Result[i]) > th):
            Q_file_rang = open("Q_file_rang.txt", 'a')
            Q_file_len = open("Q_file_len.txt", 'a')
            cnf_file = open("cnf_file.txt", 'a')
            new_val = 1 << new_shift
            new_shift += 1
            new_q = Zheg_sum(Result[i], [0, new_val])
            rang = 0
            for monom in new_q: 
              rang += count_1(monom)
            leng = len(new_q)
            for T in [3, 4, 5]:
              dnf, rng_cnf, new_value = RZP_cnf_one(new_q, T, alpha)
              string = str(dnf) + " " + str(rng_cnf) + " " + str(new_value) + " "
              cnf_file.write(string)
            cnf_file.write("\n")
            Q_file_rang.write(str(rang) + "\n")
            Q_file_len.write(str(leng) + "\n")
            Result[i].clear()
            Result[i] = [new_val]
    #  матрица - все нужные полиномы, дополнительные полиномы **** 
    M_mul = [[] for j in range(m)]
    for i in range(m):
        for j in range(m):
            list1 = transform_to_monoms(mul_to_poly(p, mds[i][j], size_p), size_p, size_p, 0) # умножение
            M_mul[i].append(list1)
    sum_ = sum_to_poly(p, size_p)
    # ****
    #M = Zheg_matrix(mds, p, m, size_p)
    for round in range(0, 2 * k ):
        C = []
        for i in range(m):
            constant_ = generate_round_constant("Rescue-Prime", p, (round + 1) * (i + 1), m - r) 
            C += transform_to_monoms(const_sum_to_poly(p, constant_, size_p), size_p, size_p, (m - i - 1) * size_p)
        # Этап S
        print('start S')
        if (round >= 1 and round % 2 != 0):
            Result, Q, new_shift = Zheg_func_subst(p, size_p, m, S0, Result, th, new_shift, size_p * m)
            #Q_final += Q
        elif (round >= 1 and round % 2 == 0):
            Result, Q, new_shift = Zheg_func_subst(p, size_p, m, S1, Result, th, new_shift, size_p * m)
            #Q_final += Q

        #print('____ M ')
        # Этап M
        print('Start M')

        Result_tmp = []
        #!!!!!!!!!!!!!!!!!!!!!!!!!
        # !!Добавить вместо подстановки в сумму - просто добавление новых переменных -- если снова упадет число 809
        for i in range(m):
            poly, Q, new_shift = Zheg_func_subst(p, size_p, m, M_mul[i][0], Result, th, new_shift, size_p) # умножение 
            #Q_final.append(Q)
            for j in range(1, m):
                print(i, j)
                poly2, Q, new_shift = Zheg_func_subst(p, size_p, m, M_mul[i][j], Result, th, new_shift, size_p) # умножение
                #Q_final.append(Q)
                for h in range(len(poly2)):
                  if (len(poly2[i]) > 1):
                    Q_file_rang = open("Q_file_rang.txt", 'a')
                    Q_file_len = open("Q_file_len.txt", 'a')
                    cnf_file = open("cnf_file.txt", 'a')
                    new_val = 1 << new_shift
                    new_shift += 1
                    #Q_final.append(Zheg_sum([0, new_val],Result[i]))
                    rang = 0
                    new_q = Zheg_sum(poly2[h], [0, new_val])
                    for monom in new_q: 
                      rang += count_1(monom)
                    leng = len(new_q)
                    for T in [3, 4, 5]:
                      dnf, rng_cnf, new_value = RZP_cnf_one(new_q, T, alpha)
                      string = str(dnf) + " " + str(rng_cnf) + " " + str(new_value) + " "
                      cnf_file.write(string)
                    cnf_file.write("\n")
                    Q_file_rang.write(str(rang) + "\n")
                    Q_file_len.write(str(leng) + "\n")
                    poly2[i].clear()
                    poly2[i] = [new_val]
                    Q_file_rang.close()
                    Q_file_len.close()
                    cnf_file.close() 
                res, Q, new_shift = Zheg_func_subst(p, size_p, m, sum_, poly + poly2, th, new_shift, 2 * size_p)
                #Q_final.append(Q)
                
                poly2.clear()
                poly.clear()
                poly = res
            Result_tmp += poly 
        Result.clear()
        Result = Result_tmp 
        #for el in Result:
        #    print(el)
        #print(" _______ M")
       # Result, Q, new_shift = Zheg_func_subst(p, size_p, m, M, Result, th, new_shift)
       # Q_final += Q

        # Этап C
        print('Start C ')
        Result, Q, new_shift = Zheg_func_subst(p, size_p, m, C, Result, th, new_shift, size_p * m)
        #Q_final += Q

    #для 2k раундов прочитать все записанные данные и записать итоговые 
    new_data = files(1, Result, new_shift, r, p, [0 for i in range(12)])
    """
    Q_file_rang = open("Q_file_rang.txt", 'w')
    Q_file_len = open("Q_file_len.txt", 'w')
    cnf_file = open("cnf_file.txt", 'w')
    Q_file_rang.close()
    Q_file_len.close()
    cnf_file.close() 
     
    os.system(r'nul>Q_file_rang.txt')
    os.system(r'nul>Q_file_len.txt')
    os.system(r'nul>Q_cnf_file.txt')
    """
    print('one more round')

    for round in range(2*k, 2*k + 2):
        C = []
        for i in range(m):
            constant_ = generate_round_constant("Rescue-Prime", p, (round + 1) * (i + 1), m - r) 
            C += transform_to_monoms(const_sum_to_poly(p, constant_, size_p), size_p, size_p, (m - i - 1) * size_p)
        # Этап S
        print('start S')
        if (round >= 1 and round % 2 != 0):
            Result, Q, new_shift = Zheg_func_subst(p, size_p, m, S0, Result, th, new_shift, size_p * m)
            #Q_final += Q
        elif (round >= 1 and round % 2 == 0):
            Result, Q, new_shift = Zheg_func_subst(p, size_p, m, S1, Result, th, new_shift, size_p * m)
            #Q_final += Q

        #print('____ M ')
        # Этап M
        print('start M')
        Result_tmp = []
        #!!!!!!!!!!!!!!!!!!!!!!!!!
        # !!Добавить вместо подстановки в сумму - просто добавление новых переменных -- если снова упадет число 809
        for i in range(m):
            poly, Q, new_shift = Zheg_func_subst(p, size_p, m, M_mul[i][0], Result, th, new_shift, size_p) # умножение 
            #Q_final.append(Q)
            for j in range(1, m):
                print(i, j)
                poly2, Q, new_shift = Zheg_func_subst(p, size_p, m, M_mul[i][j], Result, th, new_shift, size_p) # умножение
                #Q_final.append(Q)
                res, Q, new_shift = Zheg_func_subst(p, size_p, m, sum_, poly + poly2, th, new_shift, 2 * size_p)
                #Q_final.append(Q)
                poly2.clear()
                poly.clear()
                poly = res
            Result_tmp += poly 
        Result.clear()
        Result = Result_tmp 
        #for el in Result:
        #    print(el)
        #print(" _______ M")
       # Result, Q, new_shift = Zheg_func_subst(p, size_p, m, M, Result, th, new_shift)
       # Q_final += Q

        # Этап C
        print('Start C')
        Result, Q, new_shift = Zheg_func_subst(p, size_p, m, C, Result, th, new_shift, size_p * m)
        #Q_final += Q

    new_data = files(1, Result, new_shift, r, p, [0 for i in range(12)])
    
    return Result, Q_final, new_shift

from numpy.core.multiarray import result_type
from copy import deepcopy 
import math
def psi_gamma(p_ : int, A,  P : list):
    """
    A - список возможных переменных
    P - список мономов
    p - кол-во переменных в подмножествах A

    """
    sum_ = 0
    for monom in P:
        monoms_1 = count_1(A & monom) # сколько из рассматриваемых переменных из А есть в мономе
        if (monoms_1 >= p_): # считаем во сколько комбинаций входит этот моном
                sum_ += math.comb(p_, monoms_1)
        
    return sum_

def count_1(M):
    eight_bit_tab=[0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8]
    copy_M = M
    all_1 = 0
    while (copy_M > 0):
        all_1 += eight_bit_tab[copy_M & 255]
        copy_M >>= 8
    return all_1

def phi(p : int, alpha : int, a : list, M, N, P_ : list):
    b = alpha % 4
    """
    M - рассматриваемый моном 
    N - список переменных 
    P - весь список мономов

    """
    p_tmp = deepcopy(P_)
    p_tmp.remove(M)
    sum_ = 0
    for q in range(1, p + 1):
        sum_ += a[q - 1] * (psi_gamma(p, N | M, p_tmp) - psi_gamma(p, N, p_tmp))
    
    N_and_M = N & M
    M_no_N = N_and_M ^ M
    power_MN = (count_1(M_no_N)) ** b
    return (1 + sum_) / power_MN

def RZP_cnf_one(poly : list, T : int, alpha : int, new_shift : int):
    p = 2
    a = [1, 1]
    M_ = []
    R_ = []
    poly_copy = deepcopy(poly)
    for monom in poly:
        if (count_1(monom) > T):
            M_.append(monom)
            poly_copy.remove(monom)
    while (len(poly_copy) > 0): # шаг 1
        W = []
        N = 0 
        poly_c2 = deepcopy(poly_copy)
        new_monom = 0
        phi_monom = 0
        tmp_monom = []
        hit_monom = 1
        while (hit_monom > 0):
            hit_monom = 0
            for monom in poly_copy: # этап 2
                if (((N | monom) == N and N != 0) or (N == 0 and monom == 0)):
                    
                    W.append(monom) 
                    poly_c2.remove(monom)
                elif (count_1(monom | N) <= T):
                    tmp_monom.append(monom)
            poly_copy = poly_c2
            for monom in tmp_monom: # этап 3
                cur_phi = phi(p, alpha, a, monom, N, poly_c2)
                if (cur_phi > phi_monom):
                    hit_monom = 1 # нашли хотя бы 1 такой потенциальный моном
                    phi_monom = cur_phi
                    new_monom = monom
            if (hit_monom == 1):
              poly_c2.remove(new_monom)
              W.append(new_monom) 
              N = N | new_monom
            tmp_monom.clear()
            poly_copy = poly_c2
        R_.append(W)
        poly_copy = poly_c2

    # Разделили полином на две части 

    new_val = len(R_) 
    dnf = 0
    rang = 0
    for polinom in R_:
        new_value = 1 << new_shift
        new_shift += 1
        new_q = Zheg_sum(polinom, [0, new_value])
        tmp1, tmp2 = poly_table_cnf(new_q)
        dnf += tmp1 
        rang += tmp2
    tmp1, tmp2, tmp3 = afin_cnf(M_ , R_)
    dnf += tmp1 
    rang += tmp2 
    new_val += tmp3
    return dnf, rang, new_val
    
def afin_cnf(poly: list, poly2 : list):
    r = len(poly + poly2)
    D = 0
    for monom in poly:
        D += count_1(monom)
    dnf = 0
    rang = 0
    new_val = 0
    cur_e = 3
    for e in range(3, int(math.sqrt(r))):
        k = math.ceil((r - 2)/(e - 2))  -1
        tmp_dnf = 2 ** (e - 1) * (k  + 1) + D + len(poly)
        if (dnf == 0 or tmp_dnf < dnf):
            cur_e = e
            dnf = tmp_dnf
            rang = (2 ** (e - 1)) * e * (k + 1) + 3 * D + len(poly)
            new_val = k + len(poly)
    return dnf, rang, new_val

def poly_table_cnf(poly : list): 
    count_dnf = 0
    count_rank = 0
    idx = set()
    for monom in poly:
        tmp = monom
        i = 0
        while tmp > 0:
            if (tmp & 1 != 0):
                idx.add(i)
            i += 1
            tmp >>= 1
    idx = list(idx)
    for i in range(2 ** len(idx)):
        mask = 0
        for j in range(len(idx)):
            if (i & (1 << j) != 0):
                mask = mask ^ (1 << idx[j])
        result = 0
        for monom in poly:
            if (monom & mask != 0 or monom == 0):
                result = (result + 1) % 2
        if (result == 0): 
            count_rank += len(idx)
            count_dnf += 1
    return count_dnf, count_rank
poly = [1, 8, 9, 16]
poly_table_cnf(poly)

def func_subst(p : int, size_p : int, m : int, func : list, arg : list, th : int, new_val_shift : int, length : int) :# -> list, list, int
    """
        new_val_shift - сдвиг 1, чтобы обозначить новую переменную 
    """
    result_subst = []
    Q = []
    val_shift = new_val_shift
    for i in range(len(func)): # по каждому полиному, выражающему один бит
        new_final_poly = []
        for monom in func[i]:
            new_poly = [0]
            idx = 1 << (length)
            if (monom != 0):
              for j in range(length): 
                  idx >>= 1
                  # проверка длины - добавление новой переменной 
                  if (monom & idx != 0):
                      new_poly = Zheg_mul(new_poly, arg[j])
                  if (len(new_poly) > th):
                          new_val = 1 << val_shift
                          val_shift += 1
                          new_q = Zheg_sum(new_poly, [0, new_val]) 
                          new_poly = [new_val]
                          Q.append(new_q)
            new_final_poly = Zheg_sum(new_final_poly, new_poly)
            if (len(new_final_poly) > th):
                new_val = 1 << val_shift
                val_shift += 1
                new_q = Zheg_sum(new_final_poly, [0, new_val])
                new_final_poly = [new_val]
                Q.append(new_q)
        result_subst.append(new_final_poly)
    
    return result_subst, Q, val_shift

def find_result_numbers(p: int, size_p : int, mds : list, m : int, r : int, alpha : int, alpha_1 : int, N : int, th : int):
  # th = 8, 9, 10
  # T = 3, 4, 5 
  final_param_poly = [0 for i in range(3)] # количество, ранг, длина
  final_param_cnf = [[0, 0, 0] for i in range(3)]

  S_param_poly = [0 for i in range(3)]
  S_param_cnf = [[0, 0, 0] for i in range(3)]

  S1_param_poly = [0 for i in range(3)]
  S1_param_cnf = [[0, 0, 0] for i in range(3)]

  sum_param_poly = [0 for i in range(3)]
  sum_param_cnf = [[0, 0, 0] for i in range(3)] 


  # S, S^-1
  S0 = transform_to_monoms(pow_to_poly(p, alpha, size_p), size_p, size_p, 0)
  S1 = transform_to_monoms(pow_to_poly(p, alpha_1, size_p), size_p, size_p, 0)

  X = [[1 << i] for i in range(size_p - 1, -1, -1)] # для всех остальных преобразований 
  Y = [[1 << i] for i in range(size_p * 2 - 1, -1 , -1)] # Для суммы 

  # Посчитай для S все параметры 
  Result, Q, new_shift = func_subst(p, size_p, m, S0, X, th, size_p, size_p)

  for i in range(len(Result)): 
    if (len(Result[i]) > 1):
      new_val = 1 << new_shift
      new_shift += 1
      new_q = Zheg_sum(Result[i], [0, new_val])
      Q.append(new_q)
  S_param_poly[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
  for poly in Q: 
    for monom in poly: 
      S_param_poly[1] += count_1(monom) # общий ранг 
    S_param_poly[2] += len(poly) # общая длина
    for T in [3, 4, 5]:
      dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
      S_param_cnf[T - 3][0] += dnf
      S_param_cnf[T - 3][1] += rng_cnf
      S_param_cnf[T - 3][2] += new_value 
  # Посчитай для S1 все параметры 
  Result, Q, new_shift = func_subst(p, size_p, m, S1, X, th, size_p, size_p)
  for i in range(len(Result)): 
    new_val = 1 << new_shift
    new_shift += 1
    new_q = Zheg_sum(Result[i], [0, new_val])
    Q.append(new_q)
  S1_param_poly[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
  for poly in Q: 
    for monom in poly: 
      S1_param_poly[1] += count_1(monom)
    S1_param_poly[2] += len(poly)
    for T in [3, 4, 5]:
      dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
      S1_param_cnf[T - 3][0] += dnf
      S1_param_cnf[T - 3][1] += rng_cnf
      S1_param_cnf[T - 3][2] += new_value 


  # M 
  # Посчитай для произведений с константами 
  M_mul_param_poly = [[0 for i in range(3)] for j in range(m * m)]
  M_mul_param_cnf = [[[0, 0, 0] for i in range(3)] for j in range(m * m)]
  for i in range(m):
      for j in range(m):
          mul = transform_to_monoms(mul_to_poly(p, mds[i][j], size_p), size_p, size_p, 0) # умножение
          Result, Q, new_shift = func_subst(p, size_p, m, mul, X, th, size_p, size_p)
          for k in range(len(Result)): 
            if (len(Result[k]) > 1):
              new_val = 1 << new_shift
              new_shift += 1
              new_q = Zheg_sum(Result[k], [0, new_val])
              Q.append(new_q)
          M_mul_param_poly[i *m + j][0] += len(Q)    # количество новый полиномов == кол-во новых переменных
          for poly in Q: 
            for monom in poly: 
              M_mul_param_poly[i * m + j][1] += count_1(monom)
            M_mul_param_poly[i * m + j][2] += len(poly)
            for T in [3, 4, 5]:
              dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
              M_mul_param_cnf[i * m + j][T - 3][0] += dnf
              M_mul_param_cnf[i * m + j][T - 3][1] += rng_cnf
              M_mul_param_cnf[i * m + j][T - 3][2] += new_value 
  
  sum_ = sum_to_poly(p, size_p)
  # Посчитай для суммы 
  Result, Q, new_shift = func_subst(p, size_p, m, sum_, Y, th, size_p, 2 * size_p)
  for i in range(len(Result)): 
    if (len(Result[i]) > 1):
      new_val = 1 << new_shift
      new_shift += 1
      new_q = Zheg_sum(Result[i], [0, new_val])
      Q.append(new_q)
  sum_param_poly[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
  for poly in Q: 
    for monom in poly: 
      sum_param_poly[1] += count_1(monom)
    sum_param_poly[2] += len(poly)
    for T in [3, 4, 5]:
      dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
      sum_param_cnf[T - 3][0] += dnf
      sum_param_cnf[T - 3][1] += rng_cnf
      sum_param_cnf[T - 3][2] += new_value 


  # для N посчитай значения
  for Round in range(2 * N): 
    if (Round == 0):
      final_param_poly[0] += r * S_param_poly[0]
      final_param_poly[1] += r * S_param_poly[1]
      final_param_poly[2] += r * S_param_poly[2]

      for T in [3, 4, 5]:
        final_param_cnf[T - 3][0] += r * S_param_cnf[T - 3][0]
        final_param_cnf[T - 3][1] += r * S_param_cnf[T - 3][1]
        final_param_cnf[T - 3][2] += r * S_param_cnf[T - 3][2]

    elif (Round % 2 == 0 and Round != 0):

      final_param_poly[0] += m * S_param_poly[0]
      final_param_poly[1] += m * S_param_poly[1]
      final_param_poly[2] += m * S_param_poly[2]

      for T in [3, 4, 5]:
        final_param_cnf[T - 3][0] += m * S_param_cnf[T - 3][0]
        final_param_cnf[T - 3][1] += m * S_param_cnf[T - 3][1]
        final_param_cnf[T - 3][2] += m * S_param_cnf[T - 3][2]

    else:

      final_param_poly[0] += m * S1_param_poly[0]
      final_param_poly[1] += m * S1_param_poly[1]
      final_param_poly[2] += m * S1_param_poly[2]

      for T in [3, 4, 5]:
        final_param_cnf[T - 3][0] += m * S1_param_cnf[T - 3][0]
        final_param_cnf[T - 3][1] += m * S1_param_cnf[T - 3][1]
        final_param_cnf[T - 3][2] += m * S1_param_cnf[T - 3][2]
    
    # Прибавляем все параметры для суммы 
    if (Round == 0): 
      for i in range(m): 
        for j in range(r):
          final_param_poly[0] += M_mul_param_poly[i *m + j][0]
          final_param_poly[1] += M_mul_param_poly[i *m + j][1]
          final_param_poly[2] += M_mul_param_poly[i *m + j][2]
          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += M_mul_param_cnf[i * m + j][T - 3][0]
            final_param_cnf[T - 3][1] += M_mul_param_cnf[i * m + j][T - 3][1]
            final_param_cnf[T - 3][2] += M_mul_param_cnf[i * m + j][T - 3][2]
      for i in range(m):
        for j in range(r - 1):
          final_param_poly[0] += sum_param_poly[0]
          final_param_poly[1] += sum_param_poly[1]
          final_param_poly[2] += sum_param_poly[2]

          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += sum_param_cnf[T - 3][0]
            final_param_cnf[T - 3][1] += sum_param_cnf[T - 3][1]
            final_param_cnf[T - 3][2] += sum_param_cnf[T - 3][2]
          
    else:
      for i in range(m): 
        for j in range(m):
          final_param_poly[0] += M_mul_param_poly[i *m + j][0]
          final_param_poly[1] += M_mul_param_poly[i *m + j][1]
          final_param_poly[2] += M_mul_param_poly[i *m + j][2]
          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += M_mul_param_cnf[i * m + j][T - 3][0]
            final_param_cnf[T - 3][1] += M_mul_param_cnf[i * m + j][T - 3][1]
            final_param_cnf[T - 3][2] += M_mul_param_cnf[i * m + j][T - 3][2]
      for i in range(m):
        for j in range(m - 1):
          final_param_poly[0] += sum_param_poly[0]
          final_param_poly[1] += sum_param_poly[1]
          final_param_poly[2] += sum_param_poly[2]

          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += sum_param_cnf[T - 3][0]
            final_param_cnf[T - 3][1] += sum_param_cnf[T - 3][1]
            final_param_cnf[T - 3][2] += sum_param_cnf[T - 3][2]

    if (Round != 2 * N - 1):
      step = m
    else:
      step = r
    for i in range(step):
            constant_ = generate_round_constant("Rescue-Prime", p, (Round + 1) * (i + 1), m - r) 
            C = transform_to_monoms(const_sum_to_poly(p, constant_, size_p), size_p, size_p, 0)
            Result, Q, new_shift = func_subst(p, size_p, m, C, X, th, size_p, size_p)
            if (Round == 2 * N - 1):
              for l in range(size_p):
                new_val = 1 << new_shift
                Result[l] = Zheg_sum(Result[l], [0, new_val])
                new_shift += 1
                Q.append(Result[l])

            else:
              for l in range(len(Result)): 
                if (len(Result[l]) > 1):
                  new_val = 1 << new_shift
                  new_shift += 1
                  new_q = Zheg_sum(Result[l], [0, new_val])
                  Q.append(new_q)
            final_param_poly[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
            for poly in Q: 
              for monom in poly: 
                final_param_poly[1] += count_1(monom)
              final_param_poly[2] += len(poly)
              for T in [3, 4, 5]:
                dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
                final_param_cnf[T - 3][0] += dnf
                final_param_cnf[T - 3][1] += rng_cnf
                final_param_cnf[T - 3][2] += new_value 

  return final_param_poly, final_param_cnf

def radical_result_numbers(p: int, size_p : int, mds : list, m : int, r : int, alpha : int, alpha_1 : int, N : int, th : int):
  # th = 8, 9, 10
  # T = 3, 4, 5 
  final_param_poly = [0 for i in range(3)] # количество, ранг, длина
  final_param_cnf = [[0, 0, 0] for i in range(3)]

  S_param_poly = [0 for i in range(3)]
  S_param_cnf = [[0, 0, 0] for i in range(3)]

  S1_param_poly = [0 for i in range(3)]
  S1_param_cnf = [[0, 0, 0] for i in range(3)]

  sum_param_poly = [0 for i in range(3)]
  sum_param_cnf = [[0, 0, 0] for i in range(3)] 


  # S, S^-1
  S0 = transform_to_monoms(pow_to_poly(p, alpha, size_p), size_p, size_p, 0)
  S1 = transform_to_monoms(pow_to_poly(p, alpha_1, size_p), size_p, size_p, 0)

  X = [[1 << i] for i in range(size_p - 1, -1, -1)] # для всех остальных преобразований 
  Y = [[1 << i] for i in range(size_p * 2 - 1, -1 , -1)] # Для суммы 

  # Посчитай для S все параметры 
  Result, Q, new_shift = func_subst(p, size_p, m, S0, X, th, size_p, size_p)

  for i in range(len(Result)): 
    if (len(Result[i]) > 1):
      new_val = 1 << new_shift
      new_shift += 1
      new_q = Zheg_sum(Result[i], [0, new_val])
      Q.append(new_q)
  S_param_poly[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
  for poly in Q: 
    for monom in poly: 
      S_param_poly[1] += count_1(monom) # общий ранг 
    S_param_poly[2] += len(poly) # общая длина
    for T in [3, 4, 5]:
      dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
      S_param_cnf[T - 3][0] += dnf
      S_param_cnf[T - 3][1] += rng_cnf
      S_param_cnf[T - 3][2] += new_value 

  # Посчитай для S1 все параметры 
  Result, Q, new_shift = func_subst(p, size_p, m, S1, X, th, size_p, size_p)
  for i in range(len(Result)): 
    new_val = 1 << new_shift
    new_shift += 1
    new_q = Zheg_sum(Result[i], [0, new_val])
    Q.append(new_q)
  S1_param_poly[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
  for poly in Q: 
    for monom in poly: 
      S1_param_poly[1] += count_1(monom)
    S1_param_poly[2] += len(poly)
    for T in [3, 4, 5]:
      dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
      S1_param_cnf[T - 3][0] += dnf
      S1_param_cnf[T - 3][1] += rng_cnf
      S1_param_cnf[T - 3][2] += new_value 


  # M 
  # Посчитай для произведений с константами 
  M_mul_param_poly = [[0 for i in range(3)] for j in range(m * m)]
  M_mul_param_cnf = [[[0, 0, 0] for i in range(3)] for j in range(m * m)]
  for i in range(m):
      for j in range(m):
          mul = transform_to_monoms(mul_to_poly(p, mds[i][j], size_p), size_p, size_p, 0) # умножение
          Result, Q, new_shift = func_subst(p, size_p, m, mul, X, th, size_p, size_p)
          for k in range(len(Result)): 
            if (len(Result[k]) > 1):
              new_val = 1 << new_shift
              new_shift += 1
              new_q = Zheg_sum(Result[k], [0, new_val])
              Q.append(new_q)
          M_mul_param_poly[i *m + j][0] += len(Q)    # количество новый полиномов == кол-во новых переменных
          for poly in Q: 
            for monom in poly: 
              M_mul_param_poly[i * m + j][1] += count_1(monom)
            M_mul_param_poly[i * m + j][2] += len(poly)
            for T in [3, 4, 5]:
              dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
              M_mul_param_cnf[i * m + j][T - 3][0] += dnf
              M_mul_param_cnf[i * m + j][T - 3][1] += rng_cnf
              M_mul_param_cnf[i * m + j][T - 3][2] += new_value 
  
  sum_ = sum_to_poly(p, size_p)
  # Посчитай для суммы 
  print('start sum')
  Result, Q, new_shift = func_subst(p, size_p, m, sum_, Y, th, 2 * size_p, 2 * size_p)
  for i in range(len(Result)): 
    if (len(Result[i]) > 1):
      new_val = 1 << new_shift
      new_shift += 1
      new_q = Zheg_sum(Result[i], [0, new_val])
      Q.append(new_q)
  sum_param_poly[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
  print(len(Q))
  for poly in Q: 
    for monom in poly: 
      sum_param_poly[1] += count_1(monom)
    sum_param_poly[2] += len(poly)
    for T in [3, 4, 5]:
      dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
      sum_param_cnf[T - 3][0] += dnf
      sum_param_cnf[T - 3][1] += rng_cnf
      sum_param_cnf[T - 3][2] += new_value 
  print('end sum')

  # для N посчитай значения
  for Round in range(2 * N): 
    if (Round == 0):
      final_param_poly[0] += r * S_param_poly[0]
      final_param_poly[1] += r * S_param_poly[1]
      final_param_poly[2] += r * S_param_poly[2]

      for T in [3, 4, 5]:
        final_param_cnf[T - 3][0] += r * S_param_cnf[T - 3][0]
        final_param_cnf[T - 3][1] += r * S_param_cnf[T - 3][1]
        final_param_cnf[T - 3][2] += r * S_param_cnf[T - 3][2]

    elif (Round % 2 == 0 and Round != 0):

      final_param_poly[0] += m * S_param_poly[0]
      final_param_poly[1] += m * S_param_poly[1]
      final_param_poly[2] += m * S_param_poly[2]

      for T in [3, 4, 5]:
        final_param_cnf[T - 3][0] += m * S_param_cnf[T - 3][0]
        final_param_cnf[T - 3][1] += m * S_param_cnf[T - 3][1]
        final_param_cnf[T - 3][2] += m * S_param_cnf[T - 3][2]

    else:

      final_param_poly[0] += m * S1_param_poly[0]
      final_param_poly[1] += m * S1_param_poly[1]
      final_param_poly[2] += m * S1_param_poly[2]

      for T in [3, 4, 5]:
        final_param_cnf[T - 3][0] += m * S1_param_cnf[T - 3][0]
        final_param_cnf[T - 3][1] += m * S1_param_cnf[T - 3][1]
        final_param_cnf[T - 3][2] += m * S1_param_cnf[T - 3][2]
    
    # Прибавляем все параметры для суммы 
    if (Round == 0): 
      for i in range(m): 
        for j in range(r):
          final_param_poly[0] += M_mul_param_poly[i *m + j][0]
          final_param_poly[1] += M_mul_param_poly[i *m + j][1]
          final_param_poly[2] += M_mul_param_poly[i *m + j][2]
          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += M_mul_param_cnf[i * m + j][T - 3][0]
            final_param_cnf[T - 3][1] += M_mul_param_cnf[i * m + j][T - 3][1]
            final_param_cnf[T - 3][2] += M_mul_param_cnf[i * m + j][T - 3][2]
      for i in range(m):
        for j in range(r - 1):
          final_param_poly[0] += sum_param_poly[0]
          final_param_poly[1] += sum_param_poly[1]
          final_param_poly[2] += sum_param_poly[2]

          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += sum_param_cnf[T - 3][0]
            final_param_cnf[T - 3][1] += sum_param_cnf[T - 3][1]
            final_param_cnf[T - 3][2] += sum_param_cnf[T - 3][2]
          
    else:
      for i in range(m): 
        for j in range(m):
          final_param_poly[0] += M_mul_param_poly[i *m + j][0]
          final_param_poly[1] += M_mul_param_poly[i *m + j][1]
          final_param_poly[2] += M_mul_param_poly[i *m + j][2]
          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += M_mul_param_cnf[i * m + j][T - 3][0]
            final_param_cnf[T - 3][1] += M_mul_param_cnf[i * m + j][T - 3][1]
            final_param_cnf[T - 3][2] += M_mul_param_cnf[i * m + j][T - 3][2]
      for i in range(m):
        for j in range(m - 1):
          final_param_poly[0] += sum_param_poly[0]
          final_param_poly[1] += sum_param_poly[1]
          final_param_poly[2] += sum_param_poly[2]

          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += sum_param_cnf[T - 3][0]
            final_param_cnf[T - 3][1] += sum_param_cnf[T - 3][1]
            final_param_cnf[T - 3][2] += sum_param_cnf[T - 3][2]

    if (Round == 2 * N - 1):
      final_param_poly1 = final_param_poly.copy()
      final_param_cnf1 = []
      for el in final_param_cnf:
        tmp = el.copy()
        final_param_cnf1.append(tmp)
      for i in range(r):
              constant_ = generate_round_constant("Rescue-Prime", p, (Round + 1) * (i + 1), m - r) 
              C = transform_to_monoms(const_sum_to_poly(p, constant_, size_p), size_p, size_p, 0)
              Result, Q, new_shift = func_subst(p, size_p, m, C, X, th, size_p, size_p)
              if (Round == 2 * N - 1):
                for l in range(size_p):
                  new_val = 1 << new_shift
                  Result[l] = Zheg_sum(Result[l], [0, new_val])
                  new_shift += 1
                  Q.append(Result[l])

              else:
                for l in range(len(Result)): 
                  if (len(Result[l]) > 1):
                    new_val = 1 << new_shift
                    new_shift += 1
                    new_q = Zheg_sum(Result[l], [0, new_val])
                    Q.append(new_q)
              final_param_poly1[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
              for poly in Q: 
                for monom in poly: 
                  final_param_poly1[1] += count_1(monom)
                final_param_poly1[2] += len(poly)
                for T in [3, 4, 5]:
                  dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
                  final_param_cnf1[T - 3][0] += dnf
                  final_param_cnf1[T - 3][1] += rng_cnf
                  final_param_cnf1[T - 3][2] += new_value 
    for i in range(m):
            constant_ = generate_round_constant("Rescue-Prime", p, (Round + 1) * (i + 1), m - r) 
            C = transform_to_monoms(const_sum_to_poly(p, constant_, size_p), size_p, size_p, 0)
            Result, Q, new_shift = func_subst(p, size_p, m, C, X, th, size_p, size_p)
            for l in range(len(Result)): 
                if (len(Result[l]) > 1):
                  new_val = 1 << new_shift
                  new_shift += 1
                  new_q = Zheg_sum(Result[l], [0, new_val])
                  Q.append(new_q)
            final_param_poly[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
            for poly in Q: 
              for monom in poly: 
                final_param_poly[1] += count_1(monom)
              final_param_poly[2] += len(poly)
              for T in [3, 4, 5]:
                dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
                final_param_cnf[T - 3][0] += dnf
                final_param_cnf[T - 3][1] += rng_cnf
                final_param_cnf[T - 3][2] += new_value
  final_1 = []
  final_2 = []
  final_1.append(final_param_poly1)
  final_2.append(final_param_cnf1)

  for Round in range(2): 
    if (Round % 2 == 0):

      final_param_poly[0] += m * S_param_poly[0]
      final_param_poly[1] += m * S_param_poly[1]
      final_param_poly[2] += m * S_param_poly[2]

      for T in [3, 4, 5]:
        final_param_cnf[T - 3][0] += m * S_param_cnf[T - 3][0]
        final_param_cnf[T - 3][1] += m * S_param_cnf[T - 3][1]
        final_param_cnf[T - 3][2] += m * S_param_cnf[T - 3][2]

    else:

      final_param_poly[0] += m * S1_param_poly[0]
      final_param_poly[1] += m * S1_param_poly[1]
      final_param_poly[2] += m * S1_param_poly[2]

      for T in [3, 4, 5]:
        final_param_cnf[T - 3][0] += m * S1_param_cnf[T - 3][0]
        final_param_cnf[T - 3][1] += m * S1_param_cnf[T - 3][1]
        final_param_cnf[T - 3][2] += m * S1_param_cnf[T - 3][2]
    
    # Прибавляем все параметры для суммы 
    for i in range(m): 
        for j in range(m):
          final_param_poly[0] += M_mul_param_poly[i *m + j][0]
          final_param_poly[1] += M_mul_param_poly[i *m + j][1]
          final_param_poly[2] += M_mul_param_poly[i *m + j][2]
          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += M_mul_param_cnf[i * m + j][T - 3][0]
            final_param_cnf[T - 3][1] += M_mul_param_cnf[i * m + j][T - 3][1]
            final_param_cnf[T - 3][2] += M_mul_param_cnf[i * m + j][T - 3][2]
    for i in range(m):
        for j in range(m - 1):
          final_param_poly[0] += sum_param_poly[0]
          final_param_poly[1] += sum_param_poly[1]
          final_param_poly[2] += sum_param_poly[2]

          for T in [3, 4, 5]:
            final_param_cnf[T - 3][0] += sum_param_cnf[T - 3][0]
            final_param_cnf[T - 3][1] += sum_param_cnf[T - 3][1]
            final_param_cnf[T - 3][2] += sum_param_cnf[T - 3][2]

    if (Round == 1):
      step = r
    else: 
      step = m
    for i in range(step):
            constant_ = generate_round_constant("Rescue-Prime", p, (Round + 1) * (i + 1), m - r) 
            C = transform_to_monoms(const_sum_to_poly(p, constant_, size_p), size_p, size_p, 0)
            Result, Q, new_shift = func_subst(p, size_p, m, C, X, th, size_p, size_p)
            if (Round == 2 * N - 1):
              for l in range(size_p):
                new_val = 1 << new_shift
                Result[l] = Zheg_sum(Result[l], [0, new_val])
                new_shift += 1
                Q.append(Result[l])

            else:
              for l in range(len(Result)): 
                if (len(Result[l]) > 1):
                  new_val = 1 << new_shift
                  new_shift += 1
                  new_q = Zheg_sum(Result[l], [0, new_val])
                  Q.append(new_q)
            final_param_poly[0] += len(Q)    # количество новый полиномов == кол-во новых переменных
            for poly in Q: 
              for monom in poly: 
                final_param_poly[1] += count_1(monom)
              final_param_poly[2] += len(poly)
              for T in [3, 4, 5]:
                dnf, rng_cnf, new_value = RZP_cnf_one(poly, T, alpha, new_shift) 
                final_param_cnf[T - 3][0] += dnf
                final_param_cnf[T - 3][1] += rng_cnf
                final_param_cnf[T - 3][2] += new_value 
  
  final_1.append(final_param_poly)
  final_2.append(final_param_cnf)

  return final_1, final_2

incred_primes = [17, 23, 29,  41, 47, 53, 59,  71, 83, 89, 101, 107, 113, 131,149, 167, 173, 
                 179, 191, 227, 233, 239, 251, 311, 317, 347, 383, 431, 443, 479, 491, 503,
                 509, 863, 1019]
max_rang = []
max_len = []

final_len = [[] for i in range(3)]
final_rang = [[] for i in range(3)]
final_val = [[] for i in range(3)]

for idx in range(len(prime)):
  if (prime[idx] in incred_primes):
    mds = MDSs[idx]
    p = prime[idx]
    m = 3
    r = 1
    N = 4
    size_p = pow_of_p(prime[idx])
    alpha = pows[idx][0]
    cur_len = 0
    cur_rang = 0
    S0 = transform_to_monoms(pow_to_poly(p, alpha, size_p), size_p, size_p, 0)

    for poly in S0:
      if (len(poly) > cur_len):
        cur_len = len(poly)
      cur_tmp_rang = 0
      for monom in poly:
        cur_tmp_rang += count_1(monom)
      if (cur_tmp_rang > cur_rang):
        cur_rang = cur_tmp_rang

    for i in range(m):
      for j in range(m):
          mul = transform_to_monoms(mul_to_poly(p, mds[i][j], size_p), size_p, size_p, 0) 
          for poly in mul:
            if (len(poly) > cur_len):
              cur_len = len(poly)
            cur_tmp_rang = 0
            for monom in poly:
              cur_tmp_rang += count_1(monom)
            if (cur_tmp_rang > cur_rang):
              cur_rang = cur_tmp_rang

    Mult = mult_to_poly(p, size_p)
    for poly in Mult:
      if (len(poly) > cur_len):
        cur_len = len(poly)
      cur_tmp_rang = 0
      for monom in poly:
        cur_tmp_rang += count_1(monom)
      if (cur_tmp_rang > cur_rang):
        cur_rang = cur_tmp_rang
    

    Sum = sum_to_poly(p, size_p)

    for poly in Sum:
      if (len(poly) > cur_len):
        cur_len = len(poly)
      cur_tmp_rang = 0
      for monom in poly:
        cur_tmp_rang += count_1(monom)
      if (cur_tmp_rang > cur_rang):
        cur_rang = cur_tmp_rang

    for Round in range(N):
      for i in range(m):
        constant_ = generate_round_constant("Rescue-Prime", p, (Round + 1) * (i + 1), m - r) 
        C = transform_to_monoms(const_sum_to_poly(p, constant_, size_p), size_p, size_p, 0)

        for poly in C:
          if (len(poly) > cur_len):
            cur_len = len(poly)
          cur_tmp_rang = 0
          for monom in poly:
            cur_tmp_rang += count_1(monom)
          if (cur_tmp_rang > cur_rang):
            cur_rang = cur_tmp_rang
    D = cur_rang
    e = 3
    L = cur_len
    n = size_p
    print(p, n, N)
    for T in [3, 4, 5]:
      theor_len_i = (max(D + L, L * (2 ** (T + 1)) - L) + (2 ** (e - 1)) * math.ceil((L-2)/(e-2))) * (n * ((5*N - 3) * m +  r * r  + (4*N - 2)* m * m 
                                                                                                        + m * r + 3 * r))
      
      theor_rang_i = (max(3 * D + L, (T + 1 )*L * (2 ** (T + 1)) - L) + e * (2 ** (e - 1)) * math.ceil((L-2)/(e-2))) * (n * ((5*N - 3) * m +  r * r  + (4 * N - 2)* m * m 
                                                                                                        + m * r + 3 * r))
      theor_val_i = (n * ((5*N - 3) * m +  r * r  + 6* m * m  + m * r + 3 * r)) + (n * ((5*N - 3) * m +  r * r  + (4 * N - 2)* m * m  + m * r + 3 * r)) * (math.ceil((L-2)/(e-2)) - 1 + L)
      final_len[T - 3].append(theor_len_i)
      final_rang[T - 3].append(theor_rang_i)
      final_val[T - 3].append(theor_val_i)
    max_rang.append(cur_rang)
    max_len.append(cur_len)

    
import numpy as np
import matplotlib.pyplot as plt
import matplotlib

matplotlib.rcParams.update({'font.size': 12})
plt.grid(True, which ="both")

# N = 3 
# указываем в аргументе label содержание легенды 
#plt.semilogy()

# N = 3, th = 5, 6, 7
plt.plot(incred_primes, [x / 1000000 for x in final_len[0]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000000 for x in final_len[1]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000000 for x in final_len[2]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Асимпт. оценка длины КНФ при N = 3 (млн.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_len.png')
plt.show()


plt.grid(True, which ="both")

# N = 3 
# указываем в аргументе label содержание легенды 
#plt.semilogy()

# N = 3, th = 5, 6, 7
plt.plot(incred_primes, [x / 1000000 for x in final_rang[0]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000000 for x in final_rang[1]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000000 for x in final_rang[2]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Асимпт. оценка ранга КНФ при N = 3 (млн.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_rang.png')
plt.show()

"""
plt.grid(True, which ="both")

# N = 3 
# указываем в аргументе label содержание легенды 
#plt.semilogy()

# N = 3, th = 5, 6, 7
plt.plot(incred_primes, [x / 1000000 for x in final_val[0]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000000 for x in final_val[1]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000000 for x in final_val[2]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Асимп. оценка числа перем-ых КНФ при N = 3 (млн.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_val.png')
plt.show()

print()
"""
plt.grid(True, which ="both")

# N = 3 
# указываем в аргументе label содержание легенды 
#plt.semilogy()

# N = 3, th = 5, 6, 7
plt.plot(incred_primes, [x / 1000 for x in max_len], 'b:',marker='o', markersize = 2, linewidth=1)
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Макс. длина среди полиномов (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('len_max.png')
plt.show()

"""
plt.grid(True, which ="both")

# N = 3 
# указываем в аргументе label содержание легенды 
#plt.semilogy()

# N = 3, th = 5, 6, 7
plt.plot(incred_primes, max_rang, 'b:',marker='o', markersize = 2, linewidth=1)
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Макс. сумма степ. мономов 1-го полинома (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('rang_max.png')
plt.show()
"""

a1 = 0
a2 = 0
mds = []
for i in range(len(prime)):
  if (prime[i] == 41):
    mds = MDSs[i]
    a1, a2 = pows[i]
N = 3
m = 3
r = 1
p = 41
radical_result_numbers(p, pow_of_p(p), mds, m, r, a1, a2, N, 9)

prime = [13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021]

incred_primes = [13, 17, 19, 23, 29, 31, 37, 47, 53, 
                 59, 61, 67, 71, 73, 89, 97, 101, 
                 103, 113, 127, 131, 167, 191, 211, 241, 251, 
                 257, 263, 283, 313, 317, 367, 397, 439, 443,
                 449, 491, 509, 521, 577, 607, 613, 617, 701, 
                 727, 761, 821, 859, 911, 953, 1013, 1019, 1021]

m = 3
r = 1

pows = [(5, 5), 
(3, 11), 
(5, 11), 
(3, 15), 
(3, 19), 
(7, 13), 
(5, 29), 
(3, 27), 
(5, 17), 
(3, 31), 
(3, 35), 
(3, 39), 
(7, 43), 
(5, 53), 
(3, 47), 
(5, 29), 
(5, 47), 
(3, 55), 
(3, 59), 
(5, 77), 
(3, 67), 
(5, 41), 
(3, 71), 
(5, 65), 
(3, 75), 
(5, 101), 
(3, 87), 
(3, 91), 
(5, 83), 
(3, 99), 
(7, 43), 
(5, 125), 
(5, 65), 
(3, 111), 
(3, 115), 
(3, 119), 
(7, 103), 
(3, 127), 
(5, 77), 
(3, 131), 
(5, 119), 
(11, 191), 
(5, 89), 
(3, 151), 
(5, 137), 
(3, 155), 
(3, 159), 
(7, 103), 
(3, 167), 
(3, 171), 
(3, 175), 
(3, 179), 
(7, 193), 
(5, 221), 
(3, 187), 
(5, 113), 
(3, 195), 
(5, 245), 
(3, 207), 
(5, 125), 
(3, 211), 
(7, 283), 
(5, 269), 
(3, 231), 
(5, 209), 
(3, 235), 
(3, 239), 
(5, 293), 
(5, 149), 
(5, 227), 
(3, 255), 
(3, 259), 
(5, 317), 
(3, 267), 
(5, 245), 
(3, 279), 
(11, 191), 
(3, 287), 
(5, 173), 
(5, 263), 
(3, 295), 
(3, 299), 
(5, 365), 
(3, 307), 
(5, 185), 
(3, 311), 
(3, 319), 
(5, 389), 
(3, 327), 
(5, 299), 
(3, 335), 
(3, 339), 
(3, 347), 
(5, 209), 
(7, 463), 
(5, 437), 
(3, 371), 
(3, 375), 
(3, 379), 
(7, 163), 
(5, 461), 
(3, 391), 
(3, 395), 
(3, 399), 
(7, 343), 
(5, 485), 
(5, 245), 
(3, 411), 
(5, 371), 
(11, 401), 
(3, 427), 
(5, 257), 
(3, 431), 
(3, 435), 
(3, 439), 
(7, 283), 
(5, 269), 
(3, 451), 
(3, 455), 
(7, 493), 
(3, 467), 
(5, 425), 
(3, 479), 
(5, 581), 
(5, 293), 
(5, 443), 
(3, 495), 
(7, 643), 
(5, 605), 
(3, 507), 
(5, 461), 
(3, 515), 
(5, 629), 
(3, 531), 
(3, 539), 
(7, 463), 
(3, 547), 
(5, 329), 
(3, 551), 
(5, 497), 
(3, 559), 
(5, 341), 
(3, 571), 
(5, 515), 
(3, 575), 
(5, 701), 
(3, 587), 
(5, 353), 
(3, 591), 
(5, 725), 
(3, 607), 
(5, 551), 
(3, 619), 
(5, 749), 
(3, 627), 
(3, 631), 
(3, 635), 
(5, 773), 
(3, 647), 
(3, 651), 
(3, 655), 
(7, 283), 
(5, 797), 
(5, 605), 
(3, 675), 
(3, 679), 
(7, 583)]
incred_primes = []
for idx in range (len(prime)):
  if (pows[idx][0] == 3):
    incred_primes.append(prime[idx])

def aaaa(p: int, size_p : int, mds : list, m : int, r : int, alpha : int, alpha_1 : int, N : int, th : int):
  # th = 8, 9, 10
  # T = 3, 4, 5 
  Y = [[1 << i] for i in range(size_p * 2 - 1, -1 , -1)] # Для суммы 
  sum_ = sum_to_poly(p, size_p)
  # Посчитай для суммы 
  Result, Q, new_shift = func_subst(p, size_p, m, sum_, Y, th, 2 * size_p, 2 * size_p)
  for i in range(len(Result)): 
    if (len(Result[i]) > 1):
      new_val = 1 << new_shift
      new_shift += 1
      new_q = Zheg_sum(Result[i], [0, new_val])
      Q.append(new_q)    # количество новый полиномов == кол-во новых переменных
  print(len(Q))
  return 
for idx in range(len(prime)):
      p = prime[idx]
      if (p in incred_primes):
        print(p, end = " ")
        aaaa(p, pow_of_p(p), MDSs[idx], m, r, pows[idx][0], pows[idx][1], 4, 7)  
      else:
        print(p)

th = [7, 8, 9]
incred_primes = [17, 23, 29,  41, 47, 53, 59,  71, 83, 89, 101, 107, 113, 131,149, 167, 173, 
                 179, 191, 227, 233, 239, 251, 311, 317, 347, 383, 431, 443, 479, 491, 503,
                 509, 863, 1019]

N3_polynom_param_new = [[], [], []]
N3_polynom_param_rang = [[], [], []]
N3_polynom_param_len = [[], [], []]

N3_T3_dnf = [[], [], []]
N3_T3_rang = [[], [], []]
N3_T3_new_val = [[], [], []]

N3_T4_dnf = [[], [], []]
N3_T4_rang = [[], [], []]
N3_T4_new_val = [[], [], []]

N3_T5_dnf = [[], [], []]
N3_T5_rang = [[], [], []]
N3_T5_new_val = [[], [], []]

N4_T3_dnf = [[], [], []]
N4_T3_rang = [[], [], []]
N4_T3_new_val = [[], [], []]

N4_T4_dnf = [[], [], []]
N4_T4_rang = [[], [], []]
N4_T4_new_val = [[], [], []]

N4_T5_dnf = [[], [], []]
N4_T5_rang = [[], [], []]
N4_T5_new_val = [[], [], []]

N4_polynom_param_new = [[], [], []]
N4_polynom_param_rang = [[], [], []]
N4_polynom_param_len = [[], [], []]

for N in [3]:
  for idx in range(len(prime)):
    for i in range(len(th)):
      p = prime[idx]
      if (p in incred_primes):
        print(p)
        poly12, cnf12 = radical_result_numbers(p, pow_of_p(p), MDSs[idx], m, r, pows[idx][0], pows[idx][1], N, th[i])  
        poly = poly12[0]
        cnf = cnf12[0]  
        if (N == 3): 
          N3_polynom_param_new[i].append(poly[0])
          N3_polynom_param_rang[i].append(math.ceil(poly[1] / poly[0]))
          N3_polynom_param_len[i].append(math.ceil(poly[2] / poly[0]))

          N3_T3_dnf[i].append(cnf[0][0])
          N3_T3_rang[i].append(cnf[0][1])
          N3_T3_new_val[i].append(cnf[0][2] + poly[0])

          N3_T4_dnf[i].append(cnf[1][0])
          N3_T4_rang[i].append(cnf[1][1])
          N3_T4_new_val[i].append(cnf[1][2] + poly[0])

          N3_T5_dnf[i].append(cnf[2][0])
          N3_T5_rang[i].append(cnf[2][1])
          N3_T5_new_val[i].append(cnf[2][2] + poly[0])
          
          poly = poly12[1]
          cnf = cnf12[1]
          N4_polynom_param_new[i].append(poly[0])
          N4_polynom_param_rang[i].append(math.ceil(poly[1] / poly[0]))
          N4_polynom_param_len[i].append(math.ceil(poly[2] / poly[0]))

          N4_T3_dnf[i].append(cnf[0][0])
          N4_T3_rang[i].append(cnf[0][1])
          N4_T3_new_val[i].append(cnf[0][2] + poly[0])

          N4_T4_dnf[i].append(cnf[1][0])
          N4_T4_rang[i].append(cnf[1][1])
          N4_T4_new_val[i].append(cnf[1][2] + poly[0])

          N4_T5_dnf[i].append(cnf[2][0])
          N4_T5_rang[i].append(cnf[2][1])
          N4_T5_new_val[i].append(cnf[2][2] + poly[0])


incred_primes2 = [641, 677, 701, 719, 773, 
                 809, 827, 857, 911, 953, 977, 1013]

"""**Тест на константы**"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib

matplotlib.rcParams.update({'font.size': 12})
plt.grid(True, which ="both")

# N = 3 
# указываем в аргументе label содержание легенды 
#plt.semilogy()

# N = 3, th = 5, 6, 7
plt.plot(incred_primes, N3_polynom_param_len[0], 'b:',marker='o', markersize = 2, linewidth=1, label='при th = 7')
plt.plot(incred_primes, N3_polynom_param_len[1], 'black', marker = 'o', markersize = 2, linewidth=1, label='при th = 8')
plt.plot(incred_primes, N3_polynom_param_len[2], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при th = 9')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Средняя длина полиномов при N = 3', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_len.png')
plt.show()

# N = 3, th = 5, 6, 7
plt.plot(incred_primes, N3_polynom_param_rang[0], 'b:',marker='o', markersize = 2, linewidth=1, label='при th = 7')
plt.plot(incred_primes, N3_polynom_param_rang[1], 'black', marker = 'o', markersize = 2, linewidth=1, label='при th = 8')
plt.plot(incred_primes, N3_polynom_param_rang[2], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при th = 9')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Средний ранг полиномов при N = 3', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_rang.png')
plt.show()

# N = 3, th = 5, 6, 7
plt.plot(incred_primes, N3_polynom_param_new[0], 'b:',marker='o', markersize = 2, linewidth=1, label='при th = 7')
plt.plot(incred_primes, N3_polynom_param_new[1], 'black', marker = 'o', markersize = 2, linewidth=1, label='при th = 8')
plt.plot(incred_primes, N3_polynom_param_new[2], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при th = 9')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Количество полиномов при N = 3', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_poly.png')
plt.show()


# N = 4, th = 5, 6, 7
plt.plot(incred_primes, N4_polynom_param_len[0], 'b:',marker='o', markersize = 2, linewidth=1, label='при th = 7')
plt.plot(incred_primes, N4_polynom_param_len[1], 'black', marker = 'o', markersize = 2, linewidth=1, label='при th = 8')
plt.plot(incred_primes, N4_polynom_param_len[2], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при th = 9')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Средняя длина полиномов при N = 4', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_len.png')
plt.show()

# N = 4, th = 5, 6, 7
plt.plot(incred_primes, N4_polynom_param_rang[0], 'b:',marker='o', markersize = 2, linewidth=1, label='при th = 7')
plt.plot(incred_primes, N4_polynom_param_rang[1], 'black', marker = 'o', markersize = 2, linewidth=1, label='при th = 8')
plt.plot(incred_primes, N4_polynom_param_rang[2], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при th = 9')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Средний ранг полиномов при N = 4', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_rang.png')
plt.show()

# N = 4, th = 5, 6, 7
plt.plot(incred_primes, N4_polynom_param_new[0], 'b:',marker='o', markersize = 2, linewidth=1, label='при th = 7')
plt.plot(incred_primes, N4_polynom_param_new[1], 'black', marker = 'o', markersize = 2, linewidth=1, label='при th = 8')
plt.plot(incred_primes, N4_polynom_param_new[2], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при th = 9')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Количество полиномов при N = 4', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_poly.png')
plt.show()

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#N = 3, th = fix, T - all in one

matplotlib.rcParams.update({'font.size': 12})
plt.grid(True, which ="both")

# N = 3 
# указываем в аргументе label содержание легенды 
#plt.semilogy()

# N = 3, th = 6
theor = []
for i in range(len(N3_T3_dnf[0])):
  T = 3
  D = N3_polynom_param_rang[T - 3][i]
  e = 3
  N = 3
  n = pow_of_p(incred_primes[i])
  L = N3_polynom_param_len[T - 3][i]
  theor_i = (max(D + L, L * (2 ** (T + 1)) - L) + (2 ** (e - 1)) * (L-2)) * ((N-1)*(6*n*m + 4*n*m*m) + 4*n*m*m + (5*m + r)*n)
  theor.append(theor_i)

plt.plot(incred_primes, [x / 1000 for x in N3_T3_dnf[0]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N3_T4_dnf[0]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N3_T5_dnf[0]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Длина КНФ $K$ при N = 3, th = 7 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_T_dnf_th6.png')
plt.show()

plt.grid(True, which ="both")
# th = 7
plt.plot(incred_primes,[x / 1000 for x in N3_T3_dnf[1]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes,[x / 1000 for x in N3_T4_dnf[1]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes,[x / 1000 for x in N3_T5_dnf[1]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Длина КНФ $K$ при N = 3, th = 8 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_T_dnf_th7.png')
plt.show()

plt.grid(True, which ="both")
# th = 8
plt.plot(incred_primes, [x / 1000 for x in N3_T3_dnf[2]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N3_T4_dnf[2]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N3_T5_dnf[2]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Длина КНФ $K$ при N = 3, th = 9 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_T_dnf_th8.png')
plt.show()

plt.grid(True, which ="both")
# th = 6
plt.plot(incred_primes, [x / 1000 for x in N3_T3_rang[0]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N3_T4_rang[0]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N3_T5_rang[0]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Ранг КНФ $K$ при N = 3, th = 7 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_T_rg_th6.png')
plt.show()

plt.grid(True, which ="both")
# th = 7
plt.plot(incred_primes, [x / 1000 for x in N3_T3_rang[1]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N3_T4_rang[1]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N3_T5_rang[1]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Ранг КНФ $K$ при N = 3, th = 8 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_T_rg_th7.png')
plt.show()

plt.grid(True, which ="both")
# th = 8
plt.plot(incred_primes, [x / 1000 for x in N3_T3_rang[2]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N3_T4_rang[2]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N3_T5_rang[2]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Ранг КНФ $K$ при N = 3, th = 9 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_T_rg_th8.png')
plt.show()


plt.grid(True, which ="both")
#!!!!!!!!!!!!!!!
plt.plot(incred_primes, [x / 1000 for x in N4_T3_dnf[0]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N4_T4_dnf[0]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N4_T5_dnf[0]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Длина КНФ $K$ при N = 4, th = 7 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_T_dnf_th6.png')
plt.show()

plt.grid(True, which ="both")
# th = 7
plt.plot(incred_primes, [x / 1000 for x in N4_T3_dnf[1]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N4_T4_dnf[1]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N4_T5_dnf[1]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Длина КНФ $K$ при N = 4, th = 8 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_T_dnf_th7.png')
plt.show()

plt.grid(True, which ="both")
# th = 8
plt.plot(incred_primes, [x / 1000 for x in N4_T3_dnf[2]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N4_T4_dnf[2]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N4_T5_dnf[2]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Длина КНФ $K$ при N = 4, th = 9 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_T_dnf_th8.png')
plt.show()

plt.grid(True, which ="both")
# th = 6
plt.plot(incred_primes, [x / 1000 for x in N4_T3_rang[0]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N4_T4_rang[0]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N4_T5_rang[0]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Ранг КНФ $K$ при N = 4, th = 7 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_T_rg_th6.png')
plt.show()

plt.grid(True, which ="both")
# th = 7
plt.plot(incred_primes, [x / 1000 for x in N4_T3_rang[1]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N4_T4_rang[1]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N4_T5_rang[1]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Ранг КНФ $K$ при N = 4, th = 8 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_T_rg_th7.png')
plt.show()

plt.grid(True, which ="both")
# th = 8
plt.plot(incred_primes, [x / 1000 for x in N4_T3_rang[2]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000 for x in N4_T4_rang[2]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000 for x in N4_T5_rang[2]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Ранг КНФ $K$ при N = 4, th = 9 (тыс.)', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_T_rg_th8.png')
plt.show()

matplotlib.rcParams.update({'font.size': 12})
plt.grid(True, which ="both")


plt.plot(incred_primes, [x / 1000000 for x in N3_T3_new_val[0]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000000 for x in N3_T4_new_val[0]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000000 for x in N3_T5_new_val[0]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Кол-во новых переменных, N = 3, th = 7 млн.', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_T_new_val_th6.png')
plt.show()

plt.grid(True, which ="both")
# th = 7
plt.plot(incred_primes, [x / 1000000 for x in N3_T3_new_val[1]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000000 for x in N3_T4_new_val[1]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000000 for x in N3_T5_new_val[1]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Кол-во новых переменных, N = 3, th = 8 млн.', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_T_new_val_th7.png')
plt.show()

# th = 8
plt.plot(incred_primes, [x / 1000000 for x in N3_T3_new_val[2]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000000 for x in N3_T4_new_val[2]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000000 for x in N3_T5_new_val[2]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Кол-во новых переменных, N = 3, th = 9 млн.', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N3_T_new_val_th8.png')
plt.show()


plt.grid(True, which ="both")
#!!!!!!!!!!!!!!!
plt.plot(incred_primes, [x / 1000000 for x in N4_T3_new_val[0]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000000 for x in N4_T4_new_val[0]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000000 for x in N4_T5_new_val[0]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Кол-во новых переменных, N = 4, th = 7 млн.', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_T_new_val_th6.png')
plt.show()

# th = 7
plt.plot(incred_primes, [x / 1000000 for x in N4_T3_new_val[1]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000000 for x in N4_T4_new_val[1]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000000 for x in N4_T5_new_val[1]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Кол-во новых переменных, N = 4, th = 8 млн.', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_T_new_val_th7.png')
plt.show()

# th = 8
plt.plot(incred_primes, [x / 1000000 for x in N4_T3_new_val[2]], 'b:',marker='o', markersize = 2, linewidth=1, label='при T = 3')
plt.plot(incred_primes, [x / 1000000 for x in N4_T4_new_val[2]], 'black', marker = 'o', markersize = 2, linewidth=1, label='при T = 4')
plt.plot(incred_primes, [x / 1000000 for x in N4_T5_new_val[2]], color='red', linewidth=1, marker='o',  linestyle='dashed', 
         markersize=2, label='при T = 5')
plt.xlabel(r'$p$', fontsize=12)
plt.ylabel(r'Кол-во новых переменных, N = 4, th = 9 млн.', fontsize=12)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

#plt.tight_layout()
plt.savefig('N4_T_new_val_th8.png')
plt.show()



from google.colab import drive
drive.mount('/content/drive')

file_id = open("/content/drive/MyDrive/diploma/N3_polynom_param_new_6.txt", 'a')
for el in N3_polynom_param_new[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_polynom_param_new_7.txt", 'a')
for el in N3_polynom_param_new[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_polynom_param_new_8.txt", 'a')
for el in N3_polynom_param_new[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_polynom_param_len_6.txt", 'a')
for el in N3_polynom_param_len[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_polynom_param_len_7.txt", 'a')
for el in N3_polynom_param_len[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_polynom_param_len_8.txt", 'a')
for el in N3_polynom_param_len[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_polynom_param_rang_6.txt", 'a')
for el in N3_polynom_param_rang[0]:
  file_id.write(str(el) + " ")
file_id.close()
file_id = open("/content/drive/MyDrive/diploma/N3_polynom_param_rang_7.txt", 'a')
for el in N3_polynom_param_rang[1]:
  file_id.write(str(el) + " ")
file_id.close()
file_id = open("/content/drive/MyDrive/diploma/N3_polynom_param_rang_8.txt", 'a')
for el in N3_polynom_param_rang[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_polynom_param_rang_6.txt", 'a')
for el in N4_polynom_param_rang[0]:
  file_id.write(str(el) + " ")
file_id.close()
file_id = open("/content/drive/MyDrive/diploma/N4_polynom_param_rang_7.txt", 'a')
for el in N4_polynom_param_rang[1]:
  file_id.write(str(el) + " ")
file_id.close()
file_id = open("/content/drive/MyDrive/diploma/N4_polynom_param_rang_8.txt", 'a')
for el in N4_polynom_param_rang[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N4_polynom_param_len_6.txt", 'a')
for el in N4_polynom_param_len[0]:
  file_id.write(str(el) + " ")
file_id.close()
file_id = open("/content/drive/MyDrive/diploma/N4_polynom_param_len_7.txt", 'a')
for el in N4_polynom_param_len[1]:
  file_id.write(str(el) + " ")
file_id.close()
file_id = open("/content/drive/MyDrive/diploma/N4_polynom_param_len_8.txt", 'a')
for el in N4_polynom_param_len[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N4_polynom_param_new_6.txt", 'a')
for el in N4_polynom_param_new[0]:
  file_id.write(str(el) + " ")
file_id.close()
file_id = open("/content/drive/MyDrive/diploma/N4_polynom_param_len_7.txt", 'a')
for el in N4_polynom_param_new[1]:
  file_id.write(str(el) + " ")
file_id.close()
file_id = open("/content/drive/MyDrive/diploma/N4_polynom_param_new_8.txt", 'a')
for el in N4_polynom_param_new[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T3_dnf_6.txt", 'a')
for el in N4_T3_dnf[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T3_dnf_7.txt", 'a')
for el in N4_T3_dnf[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T3_dnf_8.txt", 'a')
for el in N4_T3_dnf[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N4_T3_rg_6.txt", 'a')
for el in N4_T3_rang[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T3_rg_7.txt", 'a')
for el in N4_T3_rang[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T3_rg_8.txt", 'a')
for el in N4_T3_rang[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T3_new_val_6.txt", 'a')
for el in N4_T3_new_val[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T3_new_val_7.txt", 'a')
for el in N4_T3_new_val[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T3_new_val_8.txt", 'a')
for el in N4_T3_new_val[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N3_T3_dnf_6.txt", 'a')
for el in N3_T3_dnf[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T3_dnf_7.txt", 'a')
for el in N3_T3_dnf[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T3_dnf_8.txt", 'a')
for el in N3_T3_dnf[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N3_T3_rg_6.txt", 'a')
for el in N3_T3_rang[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T3_rg_7.txt", 'a')
for el in N3_T3_rang[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T3_rg_8.txt", 'a')
for el in N3_T3_rang[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T3_new_val_6.txt", 'a')
for el in N3_T3_new_val[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T3_new_val_7.txt", 'a')
for el in N3_T3_new_val[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T3_new_val_8.txt", 'a')
for el in N3_T3_new_val[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T4_dnf_6.txt", 'a')
for el in N4_T4_dnf[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T4_dnf_7.txt", 'a')
for el in N4_T4_dnf[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T4_dnf_8.txt", 'a')
for el in N4_T4_dnf[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N4_T4_rg_6.txt", 'a')
for el in N4_T4_rang[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T4_rg_7.txt", 'a')
for el in N4_T4_rang[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T4_rg_8.txt", 'a')
for el in N4_T4_rang[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T4_new_val_6.txt", 'a')
for el in N4_T4_new_val[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T4_new_val_7.txt", 'a')
for el in N4_T4_new_val[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T4_new_val_8.txt", 'a')
for el in N4_T4_new_val[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N3_T4_dnf_6.txt", 'a')
for el in N3_T4_dnf[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T4_dnf_7.txt", 'a')
for el in N3_T4_dnf[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T4_dnf_8.txt", 'a')
for el in N3_T4_dnf[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N3_T4_rg_6.txt", 'a')
for el in N3_T4_rang[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T4_rg_7.txt", 'a')
for el in N3_T4_rang[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T4_rg_8.txt", 'a')
for el in N3_T4_rang[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T4_new_val_6.txt", 'a')
for el in N3_T4_new_val[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T4_new_val_7.txt", 'a')
for el in N3_T4_new_val[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T4_new_val_8.txt", 'a')
for el in N3_T4_new_val[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T5_dnf_6.txt", 'a')
for el in N4_T5_dnf[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T5_dnf_7.txt", 'a')
for el in N4_T5_dnf[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T5_dnf_8.txt", 'a')
for el in N4_T5_dnf[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N4_T5_rg_6.txt", 'a')
for el in N4_T5_rang[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T5_rg_7.txt", 'a')
for el in N4_T5_rang[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T5_rg_8.txt", 'a')
for el in N4_T5_rang[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T5_new_val_6.txt", 'a')
for el in N4_T5_new_val[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T5_new_val_7.txt", 'a')
for el in N4_T5_new_val[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N4_T5_new_val_8.txt", 'a')
for el in N4_T5_new_val[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N3_T5_dnf_6.txt", 'a')
for el in N3_T5_dnf[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T5_dnf_7.txt", 'a')
for el in N3_T5_dnf[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T5_dnf_8.txt", 'a')
for el in N3_T5_dnf[2]:
  file_id.write(str(el) + " ")
file_id.close()


file_id = open("/content/drive/MyDrive/diploma/N3_T5_rg_6.txt", 'a')
for el in N3_T5_rang[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T5_rg_7.txt", 'a')
for el in N3_T5_rang[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T5_rg_8.txt", 'a')
for el in N3_T5_rang[2]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T5_new_val_6.txt", 'a')
for el in N3_T5_new_val[0]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T5_new_val_7.txt", 'a')
for el in N3_T5_new_val[1]:
  file_id.write(str(el) + " ")
file_id.close()

file_id = open("/content/drive/MyDrive/diploma/N3_T5_new_val_8.txt", 'a')
for el in N3_T5_new_val[2]:
  file_id.write(str(el) + " ")
file_id.close()

from matplotlib import pyplot as plt   

prime = [13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021]


min_len = []
max_len = []
min_rank = []
max_rank = []
avg_len = []
avg_rank = []

for p in prime:
    prt = 0
    cur_min_len = -1
    cur_max_len = 0
    cur_min_rank = -1
    cur_max_rank = 0
    cur_avg_len = 0
    cur_avg_rank = 0
    for i in range(1, p):
        C = transform_to_monoms(const_sum_to_poly(p, i, pow_of_p(p)), pow_of_p(p), pow_of_p(p), 0)
        #print(i, end = " :")
        count_len = 0
        rank = 0
        for el in C:
            #print(len(el), end = " ")
            count_len += len(el)
            count_1 = 0
            for monom in el:
                while monom > 0:
                    count_1 += monom & 1
                    monom >>= 1
            rank += count_1  
        rank /= pow_of_p(p)  
        count_len /= pow_of_p(p) # средняя длина по всем полиномам
        if (cur_min_len == -1 or cur_min_len > count_len):
            cur_min_len = count_len
        if (cur_max_len < count_len):
            cur_max_len = count_len
        if (cur_min_rank == -1 or cur_min_rank > rank):
            cur_min_rank = rank 
        if (cur_max_rank < rank):
            cur_max_rank = rank
        cur_avg_len += count_len
        cur_avg_rank += rank
        #print('sr rank ', rank / pow_of_p(p), end = " , ") 
        #print('sredniy dlina',count / pow_of_p(p))
    cur_avg_len /= p - 1
    cur_avg_rank /= p - 1
    min_len.append(cur_min_len)
    min_rank.append(cur_min_rank)
    max_len.append(cur_max_len)
    max_rank.append(cur_max_rank)
    avg_len.append(cur_avg_len)
    avg_rank.append(cur_avg_rank)


"""
#ploting our canvas   
plt.plot(prime,avg_rank, 'r--')
plt.plot(prime, min_rank, 'b')
plt.plot(prime, max_rank, 'black')   
#display the graph   
plt.show()  
print()
plt.plot(prime, avg_len, 'r--')
plt.plot(prime, min_len, 'b')
plt.plot(prime, max_len, 'black')
plt.show()

"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib

matplotlib.rcParams.update({'font.size': 16})
plt.grid(True, which ="both")

# указываем в аргументе label содержание легенды 
#plt.semilogy()
plt.plot(prime, min_len, 'b:', linewidth=1, label='минимальная длина')
plt.plot(prime, max_len, 'r--', linewidth=1, label='максимальная длина')
plt.plot(prime, avg_len, color='black', linewidth=1, label='средняя длина по всем константам')

plt.xlabel(r'$p$', fontsize=16)
plt.ylabel(r'длина полиномов', fontsize=16)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

plt.tight_layout()
plt.show()

# указываем в аргументе label содержание легенды 
plt.semilogy()
plt.plot(prime, min_len, 'b:', linewidth=1, label='минимальная длина')
plt.plot(prime, max_len, 'r--', linewidth=1, label='максимальная длина')
plt.plot(prime, avg_len, color='black', linewidth=1, label='средняя длина по всем константам')

plt.xlabel(r'$p$', fontsize=16)
plt.ylabel(r'длина полиномов', fontsize=16)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

plt.tight_layout()
plt.show()

# указываем в аргументе label содержание легенды 

plt.plot(prime, min_rank, 'b:', linewidth=1, label='минимальный ранг')
plt.plot(prime, max_rank, 'r--', linewidth=1, label='максимальный ранг')
plt.plot(prime, avg_rank, color='black', linewidth=1, label='средний ранг по всем константам')

plt.xlabel(r'$p$', fontsize=16)
plt.ylabel(r'ранг полиномов', fontsize=16)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

plt.tight_layout()
plt.show()

# указываем в аргументе label содержание легенды 
plt.semilogy()
plt.plot(prime, min_rank, 'b:', linewidth=1, label='минимальный ранг')
plt.plot(prime, max_rank, 'r--', linewidth=1, label='максимальный ранг')
plt.plot(prime, avg_rank, color='black', linewidth=1, label='средний ранг по всем константам')

plt.xlabel(r'$p$', fontsize=16)
plt.ylabel(r'ранг полиномов', fontsize=16)

plt.xlim([10, 2**10 + 1])

# выводим легенду
plt.legend(fontsize=10)

plt.tight_layout()
plt.show()

"""**Преобразование S - M - C -- использование РЖП**

**Один раунд - конъюнкции**
"""

